<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TierMaster</title>
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/layout.css">
    <link rel="stylesheet" href="css/tiers.css">
    <link rel="stylesheet" href="css/items.css">
    <link rel="stylesheet" href="css/modals.css">
    <link rel="stylesheet" href="css/forced-styles.css">
    <link rel="icon" href="icon/favicon.svg" type="image/svg+xml">
    <!-- 加载外部库和模块 -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <!-- 加载自定义模块 -->
    <script src="js/i18n.js" type="module"></script>
    
    <style>
        /* 添加强制显示选择信息元素的样式 */
        .selection-info.forced-selection-info {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        /* 确保items-count元素始终可见 */
        .items-count {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .btn-danger {
            background-color: #e74c3c;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        
        /* 在非手机屏幕下的item-preview浮动定位 */
        @media screen and (min-width: 768px) {
            .main-container {
                position: relative; /* Keep for potential absolute children if any, but flex mainly for tier-list-container now */
                display: flex; /* Can still be flex to manage tier-list-container */
                align-items: flex-start;
                min-height: 500px; /* This will now primarily affect tier-list-container's environment */
            }
            
            .tier-list-container {
                flex: 1; /* Takes up available space */
                overflow-y: visible;
                /* Add margin to the right to make space for the fixed item-preview */
                margin-right: 320px; /* item-preview width (300px) + gap (e.g., 20px) */
            }
            
            .item-preview {
                position: fixed; /* CHANGED from sticky */
                /* top will be set by JS, transform is still useful */
                transform: translateY(-50%);
                width: 300px; /* Keep existing width */
                max-height: 90vh;
                overflow-y: auto;
                z-index: 5;
                /* flex-shrink: 0; REMOVED as it's no longer a flex item */
                /* left will be set by JS */
            }
        }

        /* 分享模态框样式 */
        .tierlist-preview-container {
            width: 100%;
            max-width: 800px;
            margin: 10px auto;
            background-color: #222;
            border-radius: 8px;
            overflow: hidden;
        }

        .tierlist-preview {
            width: 100%;
            height: 300px;
            overflow: auto;
            position: relative;
            background-color: #2c2c2c;
            display: flex;
            align-items: flex-start; /* 改为flex-start，使内容从顶部开始显示 */
            justify-content: center;
            padding-top: 10px; /* 添加顶部内边距 */
        }

        .preview-content {
            width: 100%;
            position: relative; /* 确保水印定位正确 */
            padding: 15px;
            background-color: #1a1a1a;
        }

        .social-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }

        .social-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            background-color: #444;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: background-color 0.3s;
        }

        .social-btn:hover {
            background-color: #555;
        }

        .social-icon {
            font-size: 18px;
        }

        .share-action-buttons {
            margin: 15px 0;
            text-align: center;
        }

        .share-link-container {
            display: flex;
            gap: 10px;
            margin: 10px 0 20px 0;
        }

        .share-modal-input {
            flex: 1;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: white;
        }

        /* 水印样式 */
        .watermark {
            position: absolute;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }
        
        .watermark-bottom {
            bottom: 10px;
            right: 10px;
        }
        
        .watermark-top {
            top: 10px;
            right: 10px;
        }

        /* 评论区样式 */
        .comment-section {
            margin-top: 0px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            width: calc(100% - 30px);
        }

        .comment-header {
            margin-bottom: 10px;
        }

        .comment-title {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 10px;
        }

        .comment-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #333;
            color: #fff;
            font-size: 14px;
            transition: border-color 0.3s;
            resize: none;
            word-wrap: break-word;
            word-break: break-all;
        }

        .comment-input:focus {
            border-color: #666;
            outline: none;
        }

        .comment-input::placeholder {
            color: #888;
        }

        .comment-input[disabled] {
            background-color: #222;
            cursor: not-allowed;
        }

        /* 评论显示样式 */
        .comment-display {
            margin-top: 10px;
            padding: 8px 12px;
            background-color: #333;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
            line-height: 1.4;
            word-wrap: break-word;
            word-break: break-all;
            white-space: pre-wrap;
            cursor: pointer;
        }

        .comment-display:hover {
            background-color: #444;
        }

        .comment-display.editing {
            display: none;
        }

        /* 在预览图片中显示评论的样式 */
        .preview-comments {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .preview-comment-item {
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            display: flex;
            align-items: flex-start;
            gap: 15px;
        }

        .preview-comment-thumbnail {
            width: 60px;
            height: 60px;
            flex-shrink: 0;
            border-radius: 4px;
            overflow: hidden;
        }

        .preview-comment-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-comment-content {
            flex: 1;
        }

        .preview-comment-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #fff;
        }

        .preview-comment-text {
            color: #ddd;
            word-wrap: break-word;
            word-break: break-all;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="site-name">TierMaster</div>
        <div class="header-buttons">
            <div class="language-selector">
                <button class="language-btn" id="language-btn">
                    <i class="lang-icon">🌎</i>
                </button>
                <div class="language-dropdown" id="language-dropdown">
                    <div class="language-option" data-lang="en">English</div>
                    <div class="language-option" data-lang="zh">中文</div>
                    <div class="language-option" data-lang="ja">日本語</div>
                    <div class="language-option" data-lang="ko">한국어</div>
                    <div class="language-option" data-lang="es">Español</div>
                    <div class="language-option" data-lang="fr">Français</div>
                    <div class="language-option" data-lang="de">Deutsch</div>
                    <div class="language-option" data-lang="it">Italiano</div>
                    <div class="language-more">More languages coming soon</div>
                </div>
            </div>
            <button class="btn btn-primary" id="buy-coffee-btn" data-i18n="buyCoffee">Buy Me a Coffee</button>
            <button class="btn btn-secondary" id="contact-btn" data-i18n="contact">Contact</button>
        </div>
    </div>
    
    <div class="main-content">
        <div class="title-section">
            <h1 id="main-title">Title</h1>
            <div class="stats">Public - 100 Participants - 1000 Votes</div>
            <div class="stats">10000 View - 1000 Like - 1000 Share</div>
        </div>
        
        <div class="action-buttons">
            <div class="action-btn tooltip" id="your-list-btn" data-i18n="yourList">
                Your List ▼
            </div>
            <div class="action-btn tooltip" id="setting-btn" data-i18n="settings">
                Settings
            </div>
            <div class="action-btn tooltip" id="share-btn" data-i18n="share">
                Share
            </div>
        </div>
        
        <div class="main-container">
            <div class="tier-list-container">
                <!-- 动态生成 tier-row -->
            </div>
            
            <div class="item-preview">
                <h2 class="item-title" data-i18n="noTitle">Item-title</h2>
                <img alt="cover" class="item-image">
                <div class="tier-colors">
                    <!-- 动态生成 color-box -->
                </div>
                <div class="preview-buttons">
                    <button class="skip-btn" data-i18n="skip">Skip</button>
                    <!-- next-btn 动态插入这里 -->
                    <button id="delete-preview-btn" class="btn delete-preview-btn" data-i18n="delete">
                        Delete
                    </button>
                </div>
                
                <div class="comment-section">
                    <div class="comment-header">
                        <div class="comment-title" data-i18n="comments">
                            Comments
                        </div>
                    </div>
                    <input id="comment-input" type="text" class="comment-input" placeholder="Write a comment..." data-i18n-placeholder="writeComment">
                </div>
            </div>
        </div>
        
        <div class="items-container">
            <div class="category-header">
                <h2 class="category-title" data-i18n="itemsTitle">Items</h2>
                <div class="action-btn tooltip" id="setting-btn2" data-i18n="settings">
                    Settings
                </div>
                <div class="action-btn tooltip" id="reset-btn" data-i18n="reset">
                    Reset
                </div>
                <div class="action-btn tooltip" id="download-btn" data-i18n="download">
                    Download
                </div>
            </div>
            
            <div class="items-grid">
                <!-- 游戏封面图 - 使用占位图 -->
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="modal-overlay"></div>
    <div id="your-list-modal" class="modal">
        <h2 data-i18n="yourList">Your List</h2>
        <p data-i18n="voteSummary">Most Votes / Average Vote</p>
        <button class="btn btn-secondary" onclick="closeModal()" data-i18n="close">Close</button>
    </div>
    <div id="setting-modal" class="modal">
        <h2 data-i18n="settings">Settings</h2>
        
        <div class="setting-section">
            <h3 data-i18n="basicSettings">Basic Settings</h3>
            <div>
                <label data-i18n="yourName">Your Name</label>
                <input id="creator-name-input" type="text" class="setting-input" placeholder="Your name here">
            </div>
            
            <div>
                <label data-i18n="titleSetting">Title</label>
                <input id="title-input" type="text" class="setting-input" value="Title">
            </div>
        </div>
        
        <div class="setting-section">
            <h3 data-i18n="tierManagement">Tier Management</h3>
            
            <div class="tier-settings-container">
                <table class="tier-settings-table">
                    <thead>
                        <tr>
                            <th data-i18n="move">Move</th>
                            <th data-i18n="tier">Tier</th>
                            <th data-i18n="tierName">Title</th>
                            <th data-i18n="tierLimit">Limit</th>
                            <th data-i18n="delete">Delete</th>
                        </tr>
                    </thead>
                    <tbody id="tier-settings-body">
                        <!-- JS will populate this -->
                    </tbody>
                </table>
                
                <div class="tier-actions">
                    <button id="add-tier-btn" class="btn btn-secondary" data-i18n="addTier">Add Tier</button>
                    <button id="reset-tiers-btn" class="btn btn-secondary" data-i18n="resetTiers">Reset to Default</button>
                </div>
            </div>
        </div>
        
        <div class="setting-section">
            <h3 data-i18n="itemsManagement">Items Management</h3>
            
            <div>
                <label data-i18n="imageSetting">Image Ratio</label>
                <select id="image-ratio-select" class="setting-select">
                    <option value="portrait" data-i18n="imagePortrait">Portrait (2:3)</option>
                    <option value="square" data-i18n="imageSquare">Square (1:1)</option>
                    <option value="landscape" data-i18n="imageLandscape">Landscape (3:2)</option>
                    <option value="round" data-i18n="imageRound">Round</option>
                </select>
            </div>
            
            <div>
                <label data-i18n="items">Items</label>
                <div class="file-selection">
                    <button id="choose-files-btn" class="btn btn-secondary" data-i18n="chooseFiles">
                        Choose Files
                    </button>
                    <span class="selection-info forced-selection-info"></span>
                </div>
                <div class="file-selection file-selection-alt">
                    <button id="type-texts-btn" class="btn btn-secondary" data-i18n="enterText">
                        Type Texts
                    </button>
                </div>
                <div class="clear-items">
                    <button id="clear-items-btn" class="btn btn-secondary clear-btn" data-i18n="clear">
                        Clear
                    </button>
                </div>
                <input type="file" id="file-input" accept="image/*" multiple class="file-input-hidden">
            </div>
        </div>
        
        
        <div class="modal-actions">
            <button id="save-settings-btn" class="btn btn-primary" data-i18n="ok">OK</button>
        </div>
    </div>
    <div id="share-modal" class="modal">
        <h2 data-i18n="shareTitle">Share</h2>
        
        <!-- 预览区域 -->
        <div class="tierlist-preview-container">
            <div id="tierlist-preview" class="tierlist-preview">
                <p data-i18n="previewLoading">Loading preview...</p>
            </div>
        </div>
        
        <!-- 下载为图片按钮 -->
        <div class="share-action-buttons">
            <button id="download-image-btn" class="btn btn-primary" data-i18n="downloadAsImage">Download as Image</button>
        </div>
        
        <!-- 分享到社交媒体 -->
        <p data-i18n="shareToSocial">Share to social media:</p>
        <div class="social-buttons">
            <button class="social-btn" data-platform="wechat"><i class="social-icon">📱</i> WeChat</button>
            <button class="social-btn" data-platform="twitter"><i class="social-icon">🐦</i> Twitter/X</button>
            <button class="social-btn" data-platform="reddit"><i class="social-icon">👽</i> Reddit</button>
            <button class="social-btn" data-platform="facebook"><i class="social-icon">👍</i> Facebook</button>
            <button class="social-btn" data-platform="weibo"><i class="social-icon">📝</i> Weibo</button>
        </div>
        
        <!-- 分享链接 -->
        <p data-i18n="shareLinkDesc">Copy link and share:</p>
        <div class="share-link-container">
            <input type="text" id="share-link-input" value="https://your-tierlist.com" readonly class="share-modal-input">
            <button id="copy-link-btn" class="btn btn-primary" data-i18n="copy">Copy</button>
        </div>
        
        <button class="btn btn-secondary close-share-modal" data-i18n="close">Close</button>
    </div>
    
    <!-- 文本输入模态窗口 -->
    <div id="text-input-modal" class="modal">
        <h2 id="text-modal-title" data-i18n="createItemsFromText">Create Items from Text</h2>
        <p id="text-modal-guide" data-i18n="textInputGuide">每行代表一个item，将自动创建卡片</p>
        
        <textarea id="text-input-area" rows="10" class="setting-input"></textarea>
        
        <div class="modal-actions">
            <button id="cancel-text-btn" class="btn btn-secondary" data-i18n="cancel">取消</button>
            <button id="generate-cards-btn" class="btn btn-primary" data-i18n="generateCards">生成卡片</button>
        </div>
    </div>

    <!-- 在其他模态窗口后面添加重置确认弹窗 -->
    <div id="reset-confirm-modal" class="modal">
        <h2 data-i18n="resetConfirmTitle">确认重置</h2>
        <p class="reset-confirm-message" data-i18n="resetConfirmMessage">您确定要重置所有分类吗？这将会把所有项目移回未分类区域并清除所有跳过状态。</p>
        <div class="modal-actions">
            <button id="cancel-reset-btn" class="btn btn-secondary" data-i18n="cancel">取消</button>
            <button id="confirm-reset-btn" class="btn btn-primary btn-danger">确认重置</button>
        </div>
    </div>

    <script type="module">
        // 移除 items.js 导入
        // import { items } from './items.js';
        // 移除 tiers.js 导入
        // import { TierManager } from './tiers.js';
        import i18n from './js/i18n.js';
        import { tierManager } from './js/tierManager.js';
        import { dbManager } from './js/dbManager.js';
        
        // 初始化时输出tierManager对象，确认其状态
        console.log('模块导入的tierManager:', tierManager);

        // 不再需要创建TierManager实例，因为tierManager.js已经创建了全局实例
        // const tierManager = new TierManager();

        // 不需要从localStorage恢复tierManager配置，tierManager.js中已经处理
        // try {
        //     const storedTiers = localStorage.getItem('tiermaker-tiers');
        //     if (storedTiers) {
        //         const tiersData = JSON.parse(storedTiers);
        //         // 恢复tiers数组
        //         if (tiersData.tiers && Array.isArray(tiersData.tiers)) {
        //             tierManager.tiers = tiersData.tiers;
        //         }
        //         // 恢复tier名称
        //         if (tiersData.tierNames) {
        //             tierManager.tierNames = tiersData.tierNames;
        //         }
        //         // 恢复tier限制
        //         if (tiersData.tierLimits) {
        //             tierManager.tierLimits = tiersData.tierLimits;
        //         }
        //         console.log('已从localStorage恢复tier设置');
        //     }
        // } catch (e) {
        //     console.error('恢复tier设置时出错:', e);
        // }
        
        // 数据结构 - 使用空数组替代导入的 items
        let items = []; // 初始化为空数组
        let unclassifiedItems = []; // 初始化为空数组
        let classifiedItems = []; // {id, tier, order}
        let skippedItems = new Set(); // 存储被跳过的item id

        // 交互状态
        let previewSelectedTier = null; // 单击高亮的tier
        let previewConfirmTier = null; // 二次确认用
        let isClassifying = false;

        // 预览索引和模式
        let previewMode = 'unclassified'; // 'unclassified' or 'classified'
        let previewIdx = 0;

        // 自定义items管理
        let currentImageRatio = 'portrait'; // 默认为portrait
        let localItems = []; // 存储本地上传的图片
        let imageCache = {}; // 全局图片缓存，避免引用错误

        // 初始化评论存储
        let itemComments = {};

        // 从localStorage加载评论
        function loadComments() {
            try {
                const savedComments = localStorage.getItem('tiermaker-comments');
                if (savedComments) {
                    itemComments = JSON.parse(savedComments);
                    console.log('已加载评论:', itemComments);
                }

                // 同时从IndexedDB加载评论
                dbManager.loadSettings(['item-comments']).then(settings => {
                    if (settings['item-comments']) {
                        // 合并从IndexedDB加载的评论
                        itemComments = { ...itemComments, ...settings['item-comments'] };
                        console.log('从IndexedDB加载评论:', settings['item-comments']);
                        // 更新显示
                        const { previewId } = getPreviewInfo();
                        if (previewId) {
                            updateCommentDisplay(previewId);
                        }
                    }
                }).catch(error => {
                    console.error('从IndexedDB加载评论失败:', error);
                });
            } catch (error) {
                console.error('加载评论失败:', error);
                itemComments = {};
            }
        }

        // 保存评论到localStorage和IndexedDB
        function saveComments() {
            try {
                // 保存到localStorage
                localStorage.setItem('tiermaker-comments', JSON.stringify(itemComments));
                console.log('已保存评论到localStorage:', itemComments);

                // 保存到IndexedDB
                dbManager.saveSettings({
                    'item-comments': itemComments
                }).then(() => {
                    console.log('已保存评论到IndexedDB');
                }).catch(error => {
                    console.error('保存评论到IndexedDB失败:', error);
                });
            } catch (error) {
                console.error('保存评论失败:', error);
            }
        }

        // 设置评论输入事件
        function setupCommentInput() {
            const commentInput = document.getElementById('comment-input');
            if (!commentInput) return;

            // 禁用评论输入框，直到有item被选中
            commentInput.disabled = true;

            // 保存评论的函数
            function saveComment() {
                const { previewId } = getPreviewInfo();
                if (!previewId) return;

                const comment = commentInput.value.trim();
                if (comment) {
                    // 保存评论
                    itemComments[previewId] = comment;
                    saveComments();
                    
                    // 更新显示
                    updateCommentDisplay(previewId);
                }
                commentInput.value = '';
            }

            // 处理回车键确认
            commentInput.addEventListener('keydown', function(e) {
                const { previewId } = getPreviewInfo();
                if (!previewId) {
                    e.preventDefault();
                    return;
                }

                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    saveComment();
                }
            });

            // 处理点击外部区域确认
            function handleClickOutside(e) {
                // 如果点击的不是评论输入框，且输入框有值，则保存评论
                if (!commentInput.contains(e.target) && commentInput.value.trim()) {
                    saveComment();
                }
            }

            // 添加点击外部区域的事件监听
            document.addEventListener('click', handleClickOutside);

            // 自动调整输入框高度
            commentInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = (this.scrollHeight) + 'px';
            });

            // 防止点击输入框时触发外部点击事件
            commentInput.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }

        // 更新评论显示
        function updateCommentDisplay(itemId) {
            const commentSection = document.querySelector('.comment-section');
            const commentInput = document.getElementById('comment-input');
            
            if (!commentSection || !commentInput) return;

            // 移除现有的评论显示（只移除.comment-display，不动输入框）
            const existingDisplay = commentSection.querySelector('.comment-display');
            if (existingDisplay) {
                existingDisplay.remove();
            }

            // 如果没有选中的item，禁用输入
            if (!itemId) {
                commentInput.disabled = true;
                commentInput.placeholder = i18n.t('selectItemFirst') || 'Select an item to comment';
                commentInput.value = '';
                commentInput.style.display = '';
                return;
            }

            // 获取评论内容
            const comment = itemComments[itemId];
            if (comment) {
                // 有评论时，显示评论内容，不显示输入框
                commentInput.style.display = 'none';
                const displayDiv = document.createElement('div');
                displayDiv.className = 'comment-display';
                displayDiv.textContent = comment;
                // 双击编辑
                displayDiv.addEventListener('dblclick', function() {
                    commentInput.value = comment;
                    commentInput.focus();
                    displayDiv.classList.add('editing');
                    commentInput.style.display = '';
                    // 自动调整输入框高度
                    commentInput.style.height = 'auto';
                    commentInput.style.height = (commentInput.scrollHeight) + 'px';
                    // 阻止事件冒泡，避免触发外部点击事件
                    displayDiv.addEventListener('click', function(e) {
                        e.stopPropagation();
                    });
                });
                commentSection.insertBefore(displayDiv, commentInput);
            } else {
                // 没有评论时，显示输入框
                commentInput.style.display = '';
                commentInput.disabled = false;
                commentInput.placeholder = i18n.t('writeComment') || 'Write a comment...';
                commentInput.value = '';
            }
        }

        // 修改renderItemPreview函数，添加评论相关功能
        const originalRenderItemPreview = renderItemPreview;
        renderItemPreview = function() {
            originalRenderItemPreview();
            
            const { previewId } = getPreviewInfo();
            updateCommentDisplay(previewId);
        };

        // 修改downloadTierListAsImage函数，添加评论显示
        const originalDownloadTierListAsImage = downloadTierListAsImage;
        downloadTierListAsImage = async function() {
            try {
                showLoadingIndicator('正在生成图片...');
                
                // 获取预览内容
                const previewContent = document.querySelector('.preview-content');
                if (!previewContent) {
                    console.error('Preview content not found');
                    hideLoadingIndicator();
                    return;
                }

                // 移除已有的评论部分（如果存在）
                const existingComments = previewContent.querySelector('.preview-comments');
                if (existingComments) {
                    existingComments.remove();
                }

                // 添加评论部分 - 在tier list之后
                const commentsWithItems = Object.entries(itemComments).filter(([id, comment]) => comment.trim());
                const commentElements = [];

                if (commentsWithItems.length > 0) {
                    commentsWithItems.forEach(([id, comment]) => {
                        const item = items.find(i => String(i.id) === String(id));
                        if (!item) return; // Skip if item not found for this comment

                        const commentItem = document.createElement('div');
                        commentItem.className = 'preview-comment-item';
                        
                        // 添加缩略图
                        const thumbnail = document.createElement('div');
                        thumbnail.className = 'preview-comment-thumbnail';
                        const thumbnailImg = document.createElement('img');
                        thumbnailImg.src = item.img;
                        thumbnailImg.alt = item.title || 'Untitled';
                        thumbnail.appendChild(thumbnailImg);
                        
                        // 添加评论内容容器
                        const content = document.createElement('div');
                        content.className = 'preview-comment-content';
                        
                        const title = document.createElement('div');
                        title.className = 'preview-comment-title';
                        title.textContent = item.title || 'Untitled';
                        
                        const text = document.createElement('div');
                        text.className = 'preview-comment-text';
                        text.textContent = comment;

                        content.appendChild(title);
                        content.appendChild(text);
                        
                        commentItem.appendChild(thumbnail);
                        commentItem.appendChild(content);
                        commentElements.push(commentItem);
                    });
                }

                if (commentElements.length > 0) { // Only add section if there are actual elements
                    const commentsSection = document.createElement('div');
                    commentsSection.className = 'preview-comments';
                    
                    const commentsTitle = document.createElement('h3');
                    commentsTitle.textContent = i18n.t('comments') || 'Comments';
                    commentsTitle.style.color = '#fff';
                    commentsTitle.style.marginBottom = '15px';
                    commentsSection.appendChild(commentsTitle);

                    commentElements.forEach(el => commentsSection.appendChild(el));
                    
                    previewContent.appendChild(commentsSection);
                }

                // 使用html2canvas库转换为Canvas
                if (typeof html2canvas !== 'function') {
                    await loadHtml2Canvas();
                }

                const canvas = await html2canvas(previewContent, {
                    backgroundColor: '#1a1a1a',
                    scale: 2,
                    logging: false,
                    useCORS: true
                });

                // 如果添加了评论部分，现在移除它
                const addedCommentsSection = previewContent.querySelector('.preview-comments');
                if (addedCommentsSection) {
                    previewContent.removeChild(addedCommentsSection);
                }

                // 转换为图片并下载
                const imgData = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = imgData;
                link.download = `TierList_${document.getElementById('main-title').textContent.replace(/[^a-zA-Z0-9_\u4e00-\u9fa5]/g, '_')}_${new Date().toISOString().slice(0,10)}.png`;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                hideLoadingIndicator();
                showSuccessMessage(i18n.t('downloadSuccess') || 'Image downloaded successfully');
            } catch (error) {
                console.error('Error downloading image:', error);
                hideLoadingIndicator();
                alert('Error generating image. Please try again.');
            }
        };

        // 在init函数中添加评论功能初始化
        const initWithComments = init;
        init = function() {
            initWithComments();
            loadComments();
            setupCommentInput();
        };

        function getGlobalPreviewOrder() {
            // 先返回所有未分类项目（包括被跳过的项目，按原始顺序）
            const unclassified = items.map(i => i.id)
                .filter(id => unclassifiedItems.includes(id));
            // 然后返回所有已分类的项目（按tier顺序）
            const classified = [];
            tierManager.getTiers().forEach(tier => {
                const arr = classifiedItems.filter(ci => ci.tier === tier)
                    .sort((a, b) => a.order - b.order);
                classified.push(...arr.map(ci => ci.id));
            });
            // 合并两个数组
            return [...unclassified, ...classified];
        }

        // 获取过滤掉跳过项目的预览顺序 - 用于决定下一个要显示的项目
        function getFilteredPreviewOrder() {
            // 先返回所有未分类且未跳过的项目（按原始顺序）
            const unclassified = items.map(i => i.id)
                .filter(id => unclassifiedItems.includes(id) && !skippedItems.has(id));
            // 然后返回所有已分类的项目（按tier顺序）
            const classified = [];
            tierManager.getTiers().forEach(tier => {
                const arr = classifiedItems.filter(ci => ci.tier === tier)
                    .sort((a, b) => a.order - b.order);
                classified.push(...arr.map(ci => ci.id));
            });
            // 合并两个数组
            return [...unclassified, ...classified];
        }

        function getPreviewInfo() {
            const orderArr = getGlobalPreviewOrder();
            const id = orderArr[previewIdx % orderArr.length];
            // 使用字符串比较确保正确匹配
            const ci = classifiedItems.find(ci => String(ci.id) === String(id));
            const isUnclassified = unclassifiedItems.includes(id) || unclassifiedItems.some(uid => String(uid) === String(id));
            return {
                previewId: id || null,
                previewTier: ci?.tier || null,
                isUnclassified,
                previewMode: isUnclassified ? 'unclassified' : 'classified'
            };
        }

        function disableColorBoxes() {
            document.querySelectorAll('.color-box').forEach(box => {
                box.style.pointerEvents = 'none';
                box.style.opacity = '0.6';
            });
        }
        function enableColorBoxes() {
            document.querySelectorAll('.color-box').forEach(box => {
                if (box.getAttribute('data-disabled') === 'true') return;
                box.style.pointerEvents = 'auto';
                box.style.opacity = '1';
            });
        }

        // 保存skippedItems到localStorage
        function saveSkippedItems() {
            try {
                localStorage.setItem('tiermaker-skipped-items', JSON.stringify(Array.from(skippedItems)));
                console.log('保存跳过项目:', Array.from(skippedItems));
            } catch (error) {
                console.error('保存跳过项目失败:', error);
            }
        }

        // 从localStorage加载skippedItems
        function loadSkippedItems() {
            try {
                const savedSkippedItems = localStorage.getItem('tiermaker-skipped-items');
                if (savedSkippedItems) {
                    skippedItems = new Set(JSON.parse(savedSkippedItems));
                    console.log('加载跳过项目:', Array.from(skippedItems));
                }
            } catch (error) {
                console.error('加载跳过项目失败:', error);
                skippedItems = new Set();
            }
        }

        // 修改gotoNextPreview函数，在标记为跳过后保存状态
        function gotoNextPreview(skip = false) {
            console.log('gotoNextPreview called, skip:', skip);
            isClassifying = true;
            disableColorBoxes();
            
            // 获取当前预览的项目
            const { previewId } = getPreviewInfo(); 
            const currentPreviewMode = getPreviewInfo().previewMode;
            console.log('当前预览项目ID:', previewId, '模式:', currentPreviewMode);
            
            // 如果是跳过操作，将当前项目标记为已跳过
            if (skip && previewId) {
                console.log('将项目标记为已跳过:', previewId);
                skippedItems.add(previewId);
                saveSkippedItems(); // 保存跳过状态
                // 同时将跳过状态保存到IndexedDB
                dbManager.saveSettings({
                    'skipped-items': Array.from(skippedItems)
                }).catch(error => {
                    console.error('保存跳过状态到IndexedDB失败:', error);
                });
                console.log('跳过后的skippedItems:', Array.from(skippedItems));
            }
            
            // 获取过滤后的顺序(不包括跳过的项目)
            const filteredOrderArr = getFilteredPreviewOrder();
            console.log('过滤后的全局顺序:', filteredOrderArr);
            
            if (filteredOrderArr.length === 0) {
                // 没有未跳过且未分类的项目，显示所有项目已分类
                previewIdx = 0;
                previewMode = 'completed'; // Now updating the global variable, not a constant
                console.log('没有未跳过且未分类的项目，显示完成状态');
            } else {
                // 按照优先级顺序：未分类且未跳过的项目 > 已分类项目
                
                // 获取所有未分类且未跳过的项目
                const unclassifiedUnskipped = unclassifiedItems.filter(id => !skippedItems.has(id));
                console.log('未分类且未跳过的项目:', unclassifiedUnskipped);
                
                if (unclassifiedUnskipped.length > 0) {
                    // 如果还有未分类且未跳过的项目，优先显示它们
                    const nextUnclassified = unclassifiedUnskipped[0]; // 取第一个
                    const globalOrder = getGlobalPreviewOrder();
                    previewIdx = globalOrder.indexOf(nextUnclassified);
                    console.log('下一个显示未分类且未跳过的项目:', nextUnclassified, '索引:', previewIdx);
                } else {
                    // 关键修改：所有未分类的项目都已被跳过或分类完成
                    // 在刚刚跳过最后一个项目的情况下(skip === true)，应该显示完成状态
                    if (skip) {
                        previewMode = 'completed';
                        previewIdx = 0;
                        console.log('刚刚跳过最后一个项目，显示完成状态');
                    }
                    // 只在非跳过操作且存在已分类项目的情况下显示已分类项目
                    else if (classifiedItems.length > 0) {
                        // 获取下一个已分类项目
                        const globalOrder = getGlobalPreviewOrder();
                        // 找到当前预览项目的后一个项目
                        if (previewId) {
                            const currentIdx = globalOrder.indexOf(previewId);
                            if (currentIdx >= 0 && currentIdx < globalOrder.length - 1) {
                                // 存在后一个项目
                                previewIdx = currentIdx + 1;
                            } else {
                                // 循环到第一个已分类项目
                                const firstClassifiedIndex = globalOrder.findIndex(id => 
                                    classifiedItems.some(ci => String(ci.id) === String(id)));
                                previewIdx = firstClassifiedIndex >= 0 ? firstClassifiedIndex : 0;
                            }
                        } else {
                            // 从第一个已分类项目开始
                            const firstClassifiedIndex = globalOrder.findIndex(id => 
                                classifiedItems.some(ci => String(ci.id) === String(id)));
                            previewIdx = firstClassifiedIndex >= 0 ? firstClassifiedIndex : 0;
                        }
                        console.log('显示已分类项目，索引:', previewIdx);
                    } else {
                        // 没有已分类项目且所有未分类项目都被跳过，显示完成状态
                        previewMode = 'completed';
                        previewIdx = 0;
                        console.log('所有项目都已被跳过，显示完成状态');
                    }
                }
            }
            
            console.log('新的预览索引:', previewIdx);
            
            previewSelectedTier = null;
            previewConfirmTier = null;
            
            // 先记录当前的skippedItems状态
            const currentSkipped = new Set(skippedItems);
            
            // 重新渲染
            rerenderAll();
            
            // 检查渲染后的skippedItems是否发生变化
            setTimeout(() => {
                console.log('渲染后的skippedItems:', Array.from(skippedItems));
                if (currentSkipped.size !== skippedItems.size) {
                    console.log('警告: skippedItems在渲染过程中发生了变化!');
                }
                isClassifying = false;
                enableColorBoxes();
            }, 0);
        }

        function classifyCurrentItem(tier) {
            const { previewId } = getPreviewInfo();
            console.log('classifyCurrentItem called, previewId:', previewId, 'tier:', tier);
            if (!previewId) return;
            
            // Check tier limit first
            const tierItems = classifiedItems.filter(ci => ci.tier === tier);
            const tierLimit = tierManager.getTierLimit(tier);
            if (tierLimit !== null && tierItems.length >= tierLimit) {
                // Highlight the tier label to show it's at limit
                highlightTierLimitReached(tier);
                return false;
            }
            
            classifiedItems.push({ id: previewId, tier, order: getTierMaxOrder(tier) + 1 });
            
            // 使用字符串比较修改未分类列表
            unclassifiedItems = unclassifiedItems.filter(id => String(id) !== String(previewId));
            
            // 不再自动重置跳过状态，除非是手动点击项目
            // skippedItems.delete(previewId);
            
            if (unclassifiedItems.length === 0 && classifiedItems.length > 0) {
                previewMode = 'classified';
                previewIdx = 0;
            } else if (previewIdx >= unclassifiedItems.length) {
                previewIdx = unclassifiedItems.length - 1;
            }
            previewSelectedTier = null;
            previewConfirmTier = null;
            
            // 保存状态
            saveItemsToLocalStorage();
            
            gotoNextPreview();
            return true;
        }
        
        function unclassifyCurrentItem() {
            const { previewId } = getPreviewInfo();
            console.log('unclassifyCurrentItem called, previewId:', previewId);
            if (!previewId) return;
            
            // 获取原始索引并在正确位置插入，在从classifiedItems中移除之前
            const originalItem = items.find(i => String(i.id) === String(previewId));
            // 使用findIndex而不是indexOf，确保使用字符串比较
            const originalIndex = originalItem ? items.findIndex(i => String(i.id) === String(previewId)) : -1;
            
            // 从classifiedItems中移除
            classifiedItems = classifiedItems.filter(ci => String(ci.id) !== String(previewId));
            
            // 清除项目的跳过状态
            skippedItems.delete(previewId);
            saveSkippedItems(); // 保存跳过状态更新
            console.log(`取消分类项目并清除跳过状态: ID=${previewId}`);
            
            // 如果找不到原始项目，添加到未分类列表末尾
            if (originalIndex === -1) {
                unclassifiedItems.push(previewId);
                console.log(`找不到原始项目索引，添加项目到未分类列表末尾: ID=${previewId}`);
                previewMode = 'unclassified';
                previewIdx = unclassifiedItems.indexOf(previewId);
                previewSelectedTier = null;
                previewConfirmTier = null;
                
                // 重要：保存状态到数据库和localStorage
                saveItemsToLocalStorage();
                
                // 然后继续预览
                gotoNextPreview();
                return;
            }
            
            // 寻找正确的插入位置
            let insertIndex = 0;
            for (let i = 0; i < unclassifiedItems.length; i++) {
                const currId = unclassifiedItems[i];
                const currItem = items.find(i => String(i.id) === String(currId));
                if (!currItem) continue;
                
                const currIndex = items.findIndex(i => String(i.id) === String(currId));
                
                if (currIndex > originalIndex) {
                    insertIndex = i;
                    break;
                }
                
                if (i === unclassifiedItems.length - 1) {
                    insertIndex = unclassifiedItems.length;
                }
            }
            
            // 当未找到合适位置时，添加到最后
            if (insertIndex === 0 && unclassifiedItems.length > 0) {
                const firstIndex = items.findIndex(i => String(i.id) === String(unclassifiedItems[0]));
                if (firstIndex > originalIndex) {
                    insertIndex = 0;
                } else {
                    insertIndex = unclassifiedItems.length;
                }
            }
            
            // 在正确位置插入
            if (unclassifiedItems.length === 0) {
                unclassifiedItems.push(previewId);
            } else {
                unclassifiedItems.splice(insertIndex, 0, previewId);
            }
            
            previewMode = 'unclassified';
            previewIdx = unclassifiedItems.indexOf(previewId);
            previewSelectedTier = null;
            previewConfirmTier = null;
            
            // 重要：保存状态到数据库和localStorage，确保取消分类操作持久化
            saveItemsToLocalStorage();
            
            // 打印日志，确认保存状态
            console.log(`取消分类完成，已保存状态: item ID=${previewId}, 插入位置=${insertIndex}, 未分类项目数=${unclassifiedItems.length}`);
            
            // 继续预览
            gotoNextPreview();
        }
        
        function changeCurrentItemTier(tier) {
            const { previewId, previewTier } = getPreviewInfo();
            console.log('changeCurrentItemTier called, previewId:', previewId, 'tier:', tier);
            if (!previewId) return;
            
            // Skip the limit check if the item is already in this tier
            const currentItem = classifiedItems.find(ci => String(ci.id) === String(previewId));
            if (currentItem && currentItem.tier === tier) {
                // Item is already in this tier, no need to check limits
                gotoNextPreview();
                return true;
            }
            
            // Check tier limit
            const tierItems = classifiedItems.filter(ci => ci.tier === tier);
            const tierLimit = tierManager.getTierLimit(tier);
            if (tierLimit !== null && tierItems.length >= tierLimit) {
                // Highlight the tier label to show it's at limit
                highlightTierLimitReached(tier);
                return false;
            }
            
            const ci = classifiedItems.find(ci => String(ci.id) === String(previewId));
            if (ci) {
                ci.tier = tier;
                ci.order = getTierMaxOrder(tier) + 1;
                reindexTierOrder();
            }
            previewSelectedTier = null;
            previewConfirmTier = null;
            
            // 保存状态
            saveItemsToLocalStorage();
            
            gotoNextPreview();
            return true;
        }
        
        // Function to highlight a tier label when limit is reached
        function highlightTierLimitReached(tier) {
            // Find the tier label
            const tierLabel = document.querySelector(`.tier-label[data-tier="${tier}"]`);
            if (tierLabel) {
                // Find the percent element
                const percentEl = tierLabel.querySelector('.tier-percent');
                if (percentEl) {
                    // Add a highlight animation
                    percentEl.classList.add('highlight-animation');
                    // Remove the animation class after it completes
                    setTimeout(() => {
                        percentEl.classList.remove('highlight-animation');
                    }, 2000);
                }
            }
        }

        // 渲染items-grid
        function renderItemsGrid() {
            const itemsGrid = document.querySelector('.items-grid');
            itemsGrid.innerHTML = '';
            
            unclassifiedItems.forEach(id => {
                const item = items.find(i => String(i.id) === String(id));
                if (!item) {
                    console.warn(`渲染items-grid: 找不到ID为${id}的项目`);
                    return; // 跳过不存在的item
                }
                
                // 创建卡片
                const card = document.createElement('div');
                card.className = `item-card ratio-${currentImageRatio}`;
                card.setAttribute('data-id', id);
                card.style.overflow = 'hidden';
                
                // 检查是否被跳过 - 使用严格的字符串比较
                const isSkipped = Array.from(skippedItems).some(skippedId => String(skippedId) === String(id));
                
                // 如果被跳过，添加skipped类
                if (isSkipped) {
                    card.classList.add('skipped');
                    console.log(`项目已被跳过: ID=${id}, 标题="${item.title}"`);
                }
                
                // 创建并添加图片
                const img = createImageElement(item.img, id, {
                    className: `item-image ratio-${currentImageRatio}`,
                    alt: item.title
                });
                
                card.appendChild(img);
                
                // 如果被跳过，添加标记
                if (isSkipped) {
                    card.appendChild(createSkippedBadge());
                }
                
                itemsGrid.appendChild(card);
            });
            
            // 更新Items计数
            const categoryTitle = document.querySelector('.category-title');
            if (categoryTitle) {
                // 计算有效的未分类items (排除被跳过的)
                const validUnclassifiedCount = unclassifiedItems.filter(id => !skippedItems.has(id)).length;
                
                // 创建或更新items-count元素
                let countSpan = categoryTitle.querySelector('.items-count');
                if (!countSpan) {
                    countSpan = document.createElement('span');
                    countSpan.className = 'items-count';
                    categoryTitle.appendChild(document.createTextNode(' '));
                    categoryTitle.appendChild(countSpan);
                }
                
                // 设置样式确保可见
                countSpan.style.display = 'inline-block';
                countSpan.style.visibility = 'visible';
                countSpan.style.opacity = '1';
                
                // 更新文本内容
                countSpan.textContent = `(${validUnclassifiedCount}/${items.length})`;
                
                // 确保categoryTitle的基本文本是正确的
                const titleText = categoryTitle.childNodes[0];
                if (titleText && titleText.nodeType === Node.TEXT_NODE) {
                    titleText.textContent = i18n.t('itemsTitle') + ' ';
                } else {
                    // 如果找不到文本节点，先清空现有内容再重新创建
                    const currentCount = countSpan.cloneNode(true);
                    categoryTitle.innerHTML = '';
                    categoryTitle.appendChild(document.createTextNode(i18n.t('itemsTitle') + ' '));
                    categoryTitle.appendChild(currentCount);
                }
            }
        }

        // 渲染tiers-list
        function renderTiersList() {
            // 清空容器
            const tierListContainer = document.querySelector('.tier-list-container');
            tierListContainer.innerHTML = '';
            
            // 调试代码：检查tierManager对象
            console.log('tierManager对象:', tierManager);
            console.log('tierManager.getTiers类型:', typeof tierManager.getTiers);
            
            // 安全获取tiers数组
            let tiers = [];
            try {
                const tiersResult = tierManager.getTiers();
                console.log('getTiers()结果:', tiersResult);
                
                // 检查结果是否为数组
                if (Array.isArray(tiersResult)) {
                    tiers = tiersResult;
                } else if (tiersResult && typeof tiersResult === 'object') {
                    // 尝试从返回结果中提取数据
                    console.log('尝试从结果中提取tiers数组');
                    if (tiersResult.tiers && Array.isArray(tiersResult.tiers)) {
                        tiers = tiersResult.tiers;
                    } else {
                        // 最后的备选方案：使用默认tiers
                        console.warn('使用默认tiers数组');
                        tiers = ['S', 'A', 'B', 'C', 'D', 'F'];
                    }
                }
            } catch (error) {
                console.error('获取tiers时出错:', error);
                // 使用默认值
                tiers = ['S', 'A', 'B', 'C', 'D', 'F'];
            }
            
            // 遍历所有tier
            tiers.forEach(tier => {
                // 创建 tier-row
                const row = document.createElement('div');
                row.className = 'tier-row';
                
                // 创建 tier-label
                const label = document.createElement('div');
                label.className = 'tier-label';
                label.textContent = tierManager.getTierName(tier);
                label.setAttribute('data-tier', tier);
                label.setAttribute('data-original-name', tierManager.getTierName(tier)); // 保存原始名称
                label.style.backgroundColor = tierManager.getTierColor(tier);
                label.style.color = '#333';
                
                // 使标签可编辑
                label.setAttribute('title', '双击编辑');
                label.style.cursor = 'pointer';
                
                // 获取该tier下的items
                const tierItems = classifiedItems
                    .filter(ci => ci.tier === tier)
                    .sort((a, b) => a.order - b.order);
                
                // 百分比和限制信息
                const percent = document.createElement('div');
                percent.className = 'tier-percent';
                const tierLimit = tierManager.getTierLimit(tier);
                if (tierLimit !== null) {
                    percent.textContent = `${tierItems.length}/${tierLimit}`;
                    // 如果快达到或已经达到限制，改变颜色
                    if (tierItems.length >= tierLimit) {
                        percent.style.color = 'rgba(255, 0, 0, 0.7)';
                    } else if (tierItems.length >= tierLimit * 0.8) {
                        percent.style.color = 'rgba(255, 165, 0, 0.7)';
                    }
                } else {
                    percent.textContent = `${tierItems.length}`;
                }
                label.appendChild(percent);
                row.appendChild(label);
                
                // tier-content
                const content = document.createElement('div');
                content.className = 'tier-content';
                content.setAttribute('data-tier', tier);
                
                // 插入该tier下的item cards
                tierItems.forEach(ci => {
                    // 从原始数组中找到完整的item
                    const originalItem = items.find(i => i.id === ci.id);
                    if (!originalItem) return; // 跳过不存在的item
                    
                    // 创建一个极简的卡片
                    const card = document.createElement('div');
                    card.className = 'item-card';
                    card.setAttribute('data-id', ci.id);
                    card.style.overflow = 'hidden';
                    
                    // 根据当前图片比例设置卡片尺寸
                    const dimensions = getCardDimensionsByRatio(currentImageRatio);
                    card.style.width = dimensions.width;
                    card.style.height = dimensions.height;
                    card.style.display = 'inline-block';
                    card.style.margin = '2px';
                    card.style.position = 'relative';
                    card.style.backgroundColor = '#333'; // 添加背景色，便于识别加载状态
                    
                    // 创建图片元素
                    const img = createImageElement(originalItem.img, ci.id, {
                        onLoad: function() {
                            card.style.backgroundColor = ''; // 移除背景色表示加载完成
                        }
                    });
                    
                    // 将图片添加到卡片
                    card.appendChild(img);
                    
                    // 添加卡片到container
                    content.appendChild(card);
                });
                
                row.appendChild(content);
                tierListContainer.appendChild(row);
            });
            
            // 用setTimeout确保图片有机会加载
            setTimeout(() => {
                document.querySelectorAll('.tier-content .item-card img').forEach(img => {
                    if (!img.complete) {
                        img.src = img.src; // 重新触发加载
                    }
                });
            }, 50);
            
            // 设置tier标签的双击编辑事件
            setupTierLabelEditEvents();
        }

        // 设置tier标签双击编辑事件
        function setupTierLabelEditEvents() {
            document.querySelectorAll('.tier-label').forEach(label => {
                // 移除现有的双击事件（如果有）
                label.removeEventListener('dblclick', handleTierLabelDblClick);
                
                // 添加双击事件
                label.addEventListener('dblclick', handleTierLabelDblClick);
            });
        }

        // 处理tier标签的双击事件
        function handleTierLabelDblClick(event) {
            // 阻止事件冒泡
            event.stopPropagation();
            
            const label = this;
            const tier = label.getAttribute('data-tier');
            if (!tier) return;
            
            // 如果正在拖拽或分类中，不允许编辑
            if (isClassifying) return;
            
            // 保存初始内容，用于取消编辑
            const originalText = label.getAttribute('data-original-name') || tierManager.getTierName(tier);
            
            // 排除点击到百分比标签的情况
            if (event.target.classList.contains('tier-percent')) return;
            
            // 创建一个输入框
            const input = document.createElement('input');
            input.type = 'text';
            input.value = originalText;
            input.className = 'tier-edit-input';
            input.style.width = '80%';
            input.style.height = '30px';
            input.style.fontSize = '16px';
            input.style.textAlign = 'center';
            input.style.border = 'none';
            input.style.outline = 'none';
            input.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            input.style.color = '#333';
            input.style.borderRadius = '4px';
            input.style.margin = '5px auto';
            input.style.display = 'block';
            
            // 保存原始内容
            const percent = label.querySelector('.tier-percent');
            const originalContent = label.innerHTML;
            
            // 清空标签并添加输入框
            label.innerHTML = '';
            label.appendChild(input);
            
            // 自动聚焦
            input.focus();
            input.select();
            
            // 保存更改
            const saveChanges = () => {
                const newName = input.value.trim();
                if (newName && newName !== originalText) {
                    // 更新tierManager中的名称
                    tierManager.setTierName(tier, newName);
                    
                    // 更新显示
                    label.textContent = newName;
                    label.setAttribute('data-original-name', newName);
                    
                    // 重新添加百分比信息
                    if (percent) {
                        label.appendChild(percent);
                    }
                    
                    // 保存到localStorage
                    localStorage.setItem('tiermaker-tiers', JSON.stringify({
                        tiers: tierManager.getTiers(),
                        tierNames: tierManager.tierNames,
                        tierLimits: tierManager.tierLimits
                    }));
                    
                    console.log(`Tier名称已更新: ${tier} => "${newName}"`);
                } else {
                    // 恢复原始内容
                    label.innerHTML = originalContent;
                }
            };
            
            // 处理按键事件
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveChanges();
                    input.blur();
                } else if (e.key === 'Escape') {
                    // 取消编辑，恢复原始内容
                    label.innerHTML = originalContent;
                    input.blur();
                }
            });
            
            // 处理失焦事件
            input.addEventListener('blur', () => {
                saveChanges();
            });
        }

        // 渲染ItemPreview
        function renderItemPreview() {
            const { previewId, previewMode, previewTier } = getPreviewInfo();
            const previewTitle = document.querySelector('.item-title');
            const skipBtn = document.querySelector('.skip-btn');
            const previewBtns = document.querySelector('.preview-buttons');
            const deleteBtn = document.getElementById('delete-preview-btn');
            
            // 清理预览容器中的所有图片元素
            const previewContainer = document.querySelector('.item-preview');
            clearImages(previewContainer);
            
            // 创建新的预览图片元素
            const newImg = document.createElement('img');
            newImg.className = 'item-image';
            
            // 动态生成 color-box
            const colorBoxContainer = document.querySelector('.tier-colors');
            colorBoxContainer.innerHTML = '';
            
            // 检查是否还有未分类且未跳过的项目
            const unclassifiedUnskippedItems = unclassifiedItems.filter(id => !skippedItems.has(id));
            const hasUnclassifiedUnskippedItems = unclassifiedUnskippedItems.length > 0;
            
            // 判断是否显示完成状态：
            const shouldShowCompleted = (!hasUnclassifiedUnskippedItems && previewMode !== 'classified' && !previewId) || 
                              (items.length > 0 && unclassifiedUnskippedItems.length === 0 && !previewId && previewMode === 'completed');
            
            // Create a grid of color boxes, max 6 per row
            const tiers = tierManager.getTiers();
            
            tiers.forEach((tier, index) => {
                const box = document.createElement('div');
                box.className = 'color-box';
                // Get tier name or custom name
                const displayName = tierManager.getTierName(tier);
                box.title = displayName + ' ' + i18n.t('tierLevel');
                box.style.backgroundColor = tierManager.getTierColor(tier);
                
                // Check if tier is at limit and disable it
                const tierItems = classifiedItems.filter(ci => ci.tier === tier);
                const tierLimit = tierManager.getTierLimit(tier);
                if (tierLimit !== null && tierItems.length >= tierLimit) {
                    if (previewMode !== 'classified' || previewTier !== tier) {
                        box.style.opacity = '0.5';
                        box.title += ' (' + i18n.t('tierLimitReached') + ')';
                        box.setAttribute('data-disabled', 'true');
                    }
                }
                colorBoxContainer.appendChild(box);
            });
            
            // 处理图片和标题
            if (previewId && !shouldShowCompleted) {
                const item = items.find(i => String(i.id) === String(previewId));
                if (!item) {
                    console.error(`预览错误: 找不到ID为${previewId}的项目`);
                    newImg.src = generateTextCardImage(i18n.t('errorItemNotFound'));
                    previewTitle.textContent = i18n.t('itemNotExist');
                    deleteBtn.style.display = 'none';
                } else {
                    previewTitle.textContent = item.title || i18n.t('noTitle');
                    deleteBtn.style.display = 'inline-block';
                    const dimensions = getPreviewDimensionsByRatio(currentImageRatio);
                    newImg.style.width = dimensions.width;
                    newImg.style.height = dimensions.height;
                    newImg.style.objectFit = 'cover';
                    if (currentImageRatio === 'round') {
                        newImg.style.borderRadius = '50%';
                    }
                    if (item.isTextGenerated) {
                        if (!item.img || item.img.indexOf('dummyimage.com') > -1) {
                            item.img = generateTextCardImage(item.title || i18n.t('noTitle'));
                            imageCache[item.id] = item.img;
                        }
                        newImg.src = item.img;
                    } else {
                        newImg.src = imageCache[item.id] || item.img;
                    }
                    newImg.onerror = function() {
                        console.error(`图片加载失败: ID=${item.id}, URL=${newImg.src}`);
                        newImg.src = generateTextCardImage(i18n.t('imageLoadError'));
                    };
                    if (previewMode === 'classified') {
                        newImg.style.border = `6px solid ${tierManager.getTierColor(previewTier)}`;
                    } else {
                        newImg.style.border = 'none';
                    }
                    console.log(`预览图片: ID=${item.id}, 标题="${item.title}", 图片类型=${item.isTextGenerated ? 'Canvas文本图片' : '普通图片'}`);
                }
            } else {
                newImg.src = generateTextCardImage(i18n.t('allItemsClassified'));
                previewTitle.textContent = i18n.t('completed');
                deleteBtn.style.display = 'none';
                newImg.style.border = 'none';
                const dimensions = getPreviewDimensionsByRatio(currentImageRatio);
                newImg.style.width = dimensions.width;
                newImg.style.height = dimensions.height;
                newImg.style.objectFit = 'cover';
                if (currentImageRatio === 'round') {
                    newImg.style.borderRadius = '50%';
                } else {
                    newImg.style.borderRadius = '';
                }
            }
            if (colorBoxContainer) {
                previewContainer.insertBefore(newImg, colorBoxContainer);
            } else {
                previewContainer.insertBefore(newImg, previewContainer.firstChild);
            }
            if (previewMode === 'classified' && previewId && !shouldShowCompleted) {
                skipBtn.textContent = i18n.t('cancel');
                if (!document.querySelector('.next-btn')) {
                    const nextBtn = document.createElement('button');
                    nextBtn.className = 'skip-btn next-btn';
                    nextBtn.textContent = i18n.t('next');
                    nextBtn.style.marginLeft = '10px';
                    previewBtns.insertBefore(nextBtn, deleteBtn);
                    nextBtn.onclick = () => gotoNextPreview();
                }
            } else {
                skipBtn.textContent = i18n.t('skip');
                const nextBtn = document.querySelector('.next-btn');
                if (nextBtn) nextBtn.remove();
            }
            document.querySelectorAll('.color-box').forEach((box, idx) => {
                const tier = tierManager.getTiers()[idx % tierManager.getTiers().length];
                if (box.getAttribute('data-disabled') === 'true') return;
                box.style.outline = '';
                if (previewMode === 'classified' && previewTier === tier) {
                    box.style.outline = '3px solid #fff';
                } else if (previewMode === 'unclassified' && previewSelectedTier === tier) {
                    box.style.outline = '3px solid #fff';
                }
            });
            setTimeout(() => {
                isClassifying = false;
                setupColorBoxEvents();
                setupSkipBtn();
                setupDeletePreviewBtn();
                setupItemTitleEditEvent();
                // 只在这里调用 updateCommentDisplay，确保只更新评论显示，不插入输入框
                const { previewId } = getPreviewInfo();
                updateCommentDisplay(previewId);
            }, 0);
        }

        // 设置删除按钮点击事件
        function setupDeletePreviewBtn() {
            const deleteBtn = document.getElementById('delete-preview-btn');
            if (deleteBtn) {
                deleteBtn.onclick = () => {
                    const { previewId } = getPreviewInfo();
                    if (!previewId) return;
                    
                    // 检查按钮是否处于确认状态
                    if (deleteBtn.getAttribute('data-confirm') === 'true') {
                        // 已经在确认状态，执行删除操作
                        deleteItem(previewId);
                        
                        // 操作完成后恢复按钮状态
                        deleteBtn.textContent = i18n.t('delete');
                        deleteBtn.style.background = '#333';
                        deleteBtn.removeAttribute('data-confirm');
                    } else {
                        // 进入确认状态
                        deleteBtn.textContent = i18n.t('confirm');
                        deleteBtn.style.background = '#ff0000';
                        deleteBtn.setAttribute('data-confirm', 'true');
                        
                        // 点击其他区域取消确认状态
                        const cancelConfirm = (e) => {
                            if (e.target !== deleteBtn) {
                                deleteBtn.textContent = i18n.t('delete');
                                deleteBtn.style.background = '#333';
                                deleteBtn.removeAttribute('data-confirm');
                                document.removeEventListener('click', cancelConfirm);
                            }
                        };
                        
                        // 延迟一下添加点击事件，避免立即触发
                        setTimeout(() => {
                            document.addEventListener('click', cancelConfirm);
                        }, 10);
                    }
                };
            }
        }

        // 重写拖放功能
        function setupMainDragDrop() {
            // 清除所有事件监听和样式
            const clearEventListeners = (selector, events) => {
                document.querySelectorAll(selector).forEach(element => {
                    events.forEach(event => {
                        element.removeAttribute(`on${event}`);
                        element[`on${event}`] = null;
                    });
                });
            };
            
            // 清除之前的事件监听
            clearEventListeners('.item-card', ['dragstart', 'dragend', 'dragover', 'dragleave', 'drop']);
            clearEventListeners('.tier-content', ['dragover', 'dragleave', 'drop']);
            
            // 移除所有指示器
            document.querySelectorAll('.drop-indicator').forEach(el => el.remove());
            
            // 确保所有卡片恢复正常样式
            document.querySelectorAll('.item-card').forEach(card => {
                card.style.opacity = '1';
                card.classList.remove('drag-highlight');
            });
            
            // 重置tier-content背景
            document.querySelectorAll('.tier-content').forEach(content => {
                content.style.background = '';
            });
            
            // 设置全局拖放对象
            const dragData = {
                dragging: false,
                itemId: null,
                sourceTier: null,
                indicators: {}
            };
            
            // 为每个tier-content创建一个专属指示器
            document.querySelectorAll('.tier-row').forEach(row => {
                const tierLabel = row.querySelector('.tier-label');
                if (!tierLabel) return;
                
                const tier = tierLabel.getAttribute('data-tier');
                const tierContent = row.querySelector('.tier-content');
                if (!tierContent) return;
                
                // 创建唯一的指示器
                const indicator = document.createElement('div');
                indicator.className = 'drop-indicator';
                indicator.style.display = 'none';
                indicator.setAttribute('data-tier', tier);
                tierContent.appendChild(indicator);
                
                // 存储指示器引用
                dragData.indicators[tier] = indicator;
            });
            
            // 使items-grid中的卡片可拖拽
            document.querySelectorAll('.items-grid .item-card').forEach(card => {
                card.setAttribute('draggable', 'true');
                
                card.ondragstart = (e) => {
                    // 获取卡片ID - 直接使用属性值，不进行类型转换
                    const id = card.getAttribute('data-id');
                    
                    // 保存拖拽数据到dataTransfer
                    e.dataTransfer.setData('text/plain', id);
                    e.dataTransfer.effectAllowed = 'move';
                    
                    // 降低透明度
                    card.style.opacity = '0.1';
                    
                    // 同时保存到全局变量
                    dragData.dragging = true;
                    dragData.itemId = id;
                    dragData.sourceTier = null;
                };
                
                card.ondragend = (e) => {
                    card.style.opacity = '1';
                    dragData.dragging = false;
                    dragData.itemId = null;
                    
                    // 隐藏所有指示器
                    Object.values(dragData.indicators).forEach(ind => {
                        ind.style.display = 'none';
                    });
                    
                    // 移除所有高亮
                    document.querySelectorAll('.drag-highlight').forEach(el => {
                        el.classList.remove('drag-highlight');
                    });
                    
                    // 重置tier背景
                    document.querySelectorAll('.tier-content').forEach(content => {
                        content.style.background = '';
                    });
                };
            });
            
            // 使tier-content中的卡片可拖拽
            document.querySelectorAll('.tier-content .item-card').forEach(card => {
                card.setAttribute('draggable', 'true');
                
                card.ondragstart = (e) => {
                    // 获取卡片ID - 直接使用属性值，不进行类型转换
                    const id = card.getAttribute('data-id');
                    
                    // 获取源tier
                    const tierContent = card.closest('.tier-content');
                    const tierRow = tierContent.closest('.tier-row');
                    const tierLabel = tierRow.querySelector('.tier-label');
                    const tier = tierLabel.getAttribute('data-tier');
                    
                    // 保存拖拽数据到dataTransfer
                    e.dataTransfer.setData('text/plain', id);
                    e.dataTransfer.setData('sourceTier', tier);
                    e.dataTransfer.effectAllowed = 'move';
                    
                    // 降低透明度 - 更透明
                    card.style.opacity = '0.2';
                    
                    // 同时保存到全局变量
                    dragData.dragging = true;
                    dragData.itemId = id;
                    dragData.sourceTier = tier;
                };
                
                card.ondragend = (e) => {
                    card.style.opacity = '1';
                    dragData.dragging = false;
                    dragData.itemId = null;
                    dragData.sourceTier = null;
                    
                    // 隐藏所有指示器
                    Object.values(dragData.indicators).forEach(ind => {
                        ind.style.display = 'none';
                    });
                    
                    // 移除所有高亮
                    document.querySelectorAll('.drag-highlight').forEach(el => {
                        el.classList.remove('drag-highlight');
                    });
                    
                    // 重置tier背景
                    document.querySelectorAll('.tier-content').forEach(content => {
                        content.style.background = '';
                    });
                };
            });
            
            // 处理tier-content的拖放事件
            document.querySelectorAll('.tier-content').forEach(content => {
                const tierRow = content.closest('.tier-row');
                const tierLabel = tierRow.querySelector('.tier-label');
                const tier = tierLabel.getAttribute('data-tier');
                const indicator = dragData.indicators[tier];
                
                content.ondragover = (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    if (!dragData.dragging && !e.dataTransfer.getData('text/plain')) return;
                    
                    // 基本样式
                    content.style.background = 'rgba(255,255,255,0.05)';
                    
                    // 确保指示器存在
                    let indicator = dragData.indicators[tier];
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.className = 'drop-indicator';
                        indicator.setAttribute('data-tier', tier);
                        content.appendChild(indicator);
                        dragData.indicators[tier] = indicator;
                    }
                    
                    // 获取拖拽数据 - 优先使用全局变量
                    const id = dragData.itemId || e.dataTransfer.getData('text/plain');
                    const sourceTier = dragData.sourceTier || e.dataTransfer.getData('sourceTier');
                    const source = sourceTier ? 'tier-content' : 'items-grid';
                    
                    // 检查tier限制
                    const tierItems = classifiedItems.filter(ci => ci.tier === tier);
                    const tierLimit = tierManager.getTierLimit(tier);
                    
                    // 是否来自同一tier或已在该tier
                    const isFromSameTier = sourceTier === tier;
                    const isAlreadyInTier = classifiedItems.some(ci => String(ci.id) === String(id) && ci.tier === tier);
                    
                    // 检查tier限制
                    if (!isFromSameTier && !isAlreadyInTier && tierLimit !== null && tierItems.length >= tierLimit) {
                        // 达到限制，显示红色背景
                        content.style.background = 'rgba(255,0,0,0.2)';
                        indicator.style.display = 'none';
                        return;
                    }
                    
                    // 获取所有卡片
                    let items = Array.from(content.querySelectorAll('.item-card'));
                    
                    // 排除被拖拽的卡片
                    if (isFromSameTier) {
                        items = items.filter(item => item.getAttribute('data-id') !== id);
                    }
                    
                    // 显示放置指示器
                    const dropInfo = calculateDropPosition(e, content, items);
                    
                    // 显示指示器
                    indicator.style.display = 'block';
                    indicator.style.left = dropInfo.indicatorX + 'px';
                    
                    // 始终设置精确的高度和位置
                    indicator.style.height = dropInfo.indicatorHeight + 'px';
                    indicator.style.top = dropInfo.indicatorY + 'px';
                    
                    // 移除其他高亮
                    items.forEach(item => item.classList.remove('drag-highlight'));
                    
                    // 如果有目标item，高亮它
                    if (dropInfo.targetItem) {
                        dropInfo.targetItem.classList.add('drag-highlight');
                    }
                };
                
                content.ondragleave = (e) => {
                    content.style.background = '';
                    indicator.style.display = 'none';
                    
                    // 移除所有高亮
                    content.querySelectorAll('.drag-highlight').forEach(item => {
                        item.classList.remove('drag-highlight');
                    });
                };
                
                content.ondrop = (e) => {
                    e.preventDefault();
                    content.style.background = '';
                    indicator.style.display = 'none';
                    
                    // 移除所有高亮
                    content.querySelectorAll('.drag-highlight').forEach(item => {
                        item.classList.remove('drag-highlight');
                    });
                    
                    // 解析拖拽数据 - 从全局变量获取，更可靠
                    const id = dragData.itemId;
                    const sourceTier = dragData.sourceTier;
                    const sourceType = sourceTier ? 'tier' : 'grid';
                    
                    if (!id) return;
                    
                    // 获取放置位置
                    const items = Array.from(content.querySelectorAll('.item-card'));
                    const dropPosition = calculateDropPosition(e, content, items.filter(item => item.getAttribute('data-id') !== id));
                    
                    // 构建拖放数据对象
                    const dropData = {
                        id: id,
                        sourceType: sourceType, 
                        targetType: 'tier',
                        sourceTier: sourceTier, 
                        targetTier: tier,
                        dropIndex: dropPosition.dropIndex
                    };
                    
                    // 使用通用函数处理拖放
                    handleDragDrop(dropData);
                };
            });

            // 清理拖动结束事件
            document.querySelectorAll('.item-card').forEach(card => {
                const existingDragend = card.ondragend;
                card.ondragend = (e) => {
                    // 调用原来的处理函数
                    if (existingDragend) existingDragend.call(card, e);
                    
                    // 隐藏所有区域指示器
                    if (dragData.areaIndicators) {
                        Object.values(dragData.areaIndicators).forEach(ind => {
                            if (ind) ind.style.display = 'none';
                        });
                    }
                };
            });
            
            // 绑定点击事件
            bindItemClickEvents();
        }

        // 处理items-grid到tier的拖放
        function handleGridToTier(id, tier, dropIndex) {
            console.log('处理从grid到tier的拖放:', id, tier, dropIndex);
            
            // 查找完整的item数据
            const originalItem = items.find(i => String(i.id) === String(id));
            if (!originalItem) {
                console.error(`拖放错误: 找不到ID为${id}的项目`);
                return;
            }
            
            console.log(`拖放项目: ID=${id}, Title=${originalItem.title}`);
            
            // 计算order值
            const order = getOrderForPosition(tier, dropIndex);
            
            // 添加到classifiedItems
            classifiedItems.push({ id, tier, order });
            
            // 从unclassifiedItems中移除 - 使用字符串比较
            unclassifiedItems = unclassifiedItems.filter(i => String(i) !== String(id));
            
            // 手动拖拽分类时重置跳过状态
            skippedItems.delete(id);
            saveSkippedItems(); // 保存跳过状态更新
            
            // 重新索引该tier中的items
            reindexTierItems(tier);
            
            // 保存到localStorage确保持久化
            saveItemsToLocalStorage();
            
            // 清除预览图片
            const previewContainer = document.querySelector('.item-preview');
            const oldImages = previewContainer.querySelectorAll('.item-image');
            oldImages.forEach(img => img.remove());
            
            // 重新渲染
            rerenderAll();
        }

        // 处理同一tier内的排序
        function handleSameTierSort(id, tier, dropIndex) {
            console.log('处理同一tier内排序:', id, tier, dropIndex);
            
            // 查找完整的item数据
            const originalItem = items.find(i => i.id === id);
            if (!originalItem) {
                console.error(`排序错误: 找不到ID为${id}的项目`);
                        return;
                    }
            
            console.log(`排序项目: ID=${id}, Title=${originalItem.title}`);
            
            // 获取该tier中的所有items
            const tierItems = classifiedItems
                .filter(ci => ci.tier === tier)
                .sort((a, b) => a.order - b.order);
            
            // 找到被拖拽的item
            const draggedItem = tierItems.find(ti => ti.id === id);
            if (!draggedItem) return;
            
            // 当前位置
            const oldIndex = tierItems.indexOf(draggedItem);
            
            // 如果位置没变，不做任何操作
            if (oldIndex === dropIndex) return;
            
            // 移动item
            tierItems.splice(oldIndex, 1);
            tierItems.splice(dropIndex, 0, draggedItem);
            
            // 重新设置order
            tierItems.forEach((item, index) => {
                item.order = index + 1;
            });
            
            // 保存到localStorage确保持久化
            saveItemsToLocalStorage();
            
            // 清除预览图片
            const previewContainer = document.querySelector('.item-preview');
            const oldImages = previewContainer.querySelectorAll('.item-image');
            oldImages.forEach(img => img.remove());
            
            // 重新渲染
                        rerenderAll();
        }

        // 处理从一个tier到另一个tier的拖放
        function handleTierToTier(id, sourceTier, targetTier, dropIndex) {
            console.log('处理从tier到tier的拖放:', id, sourceTier, targetTier, dropIndex);
            
            // 查找完整的item数据
            const originalItem = items.find(i => i.id === id);
            if (!originalItem) {
                console.error(`拖放错误: 找不到ID为${id}的项目`);
                        return;
                    }
            
            console.log(`Tier间拖放项目: ID=${id}, Title=${originalItem.title}`);
            
            // 找到被拖拽的item
            const item = classifiedItems.find(ci => ci.id === id);
            if (!item) return;
            
            // 更新tier
            item.tier = targetTier;
            
            // 计算新的order
            item.order = getOrderForPosition(targetTier, dropIndex);
            
            // 重新索引两个tier的items
            reindexTierItems(sourceTier);
            reindexTierItems(targetTier);
            
            // 保存到localStorage确保持久化
            saveItemsToLocalStorage();
            
            // 清除预览图片
            const previewContainer = document.querySelector('.item-preview');
            const oldImages = previewContainer.querySelectorAll('.item-image');
            oldImages.forEach(img => img.remove());
            
            // 重新渲染
            rerenderAll();
        }

        // 验证所有卡片图片是否正确
        function verifyCardImages() {
            document.querySelectorAll('.item-card').forEach(card => {
                const cardId = card.getAttribute('data-id');
                const img = card.querySelector('img');
                if (img && cardId) {
                    const cardItem = items.find(i => String(i.id) === String(cardId));
                    if (cardItem && img.src !== cardItem.img && !img.src.includes('Error')) {
                        console.warn(`检测到图片源不匹配: 卡片ID=${cardId}, 图片源=${img.src}, 应为=${cardItem.img}`);
                        // 强制重置图片源
                        img.src = cardItem.img;
                    }
                }
            });
        }

        // 显示放置指示器
        function showDropIndicator(e, container, items, indicator) {
            // 计算放置位置
            const dropInfo = calculateDropPosition(e, container, items);
            
            // 显示指示器
            indicator.style.display = 'block';
            indicator.style.left = dropInfo.indicatorX + 'px';
            indicator.style.height = '90%';
            indicator.style.top = '5%';
            
            // 移除其他高亮
            items.forEach(item => item.classList.remove('drag-highlight'));
            
            // 如果有目标item，高亮它
            if (dropInfo.targetItem) {
                dropInfo.targetItem.classList.add('drag-highlight');
            }
        }

        // 添加一个全局UI一致性检查函数
        function ensureUIConsistency() {
            // 简化版 - 只做最必要的更新
            try {
                // 更新项目计数 - 使用更轻量的方法
                const itemsCountEl = document.getElementById('items-count');
                if (itemsCountEl) {
                    itemsCountEl.textContent = items.length.toString();
                }
                
                // 更新selection-info元素 - 简化处理
                const selectionInfo = document.querySelector('.selection-info');
                if (selectionInfo) {
                    const selectedItemsText = i18n.t('selectedItems');
                    selectionInfo.innerHTML = `${selectedItemsText} (${items.length})`;
                    selectionInfo.style.display = 'inline-block';
                }
                
                // 更新预览标题 - 只在必要时更新
                const { previewId } = getPreviewInfo();
                if (previewId) {
                    const item = items.find(i => String(i.id) === String(previewId));
                    if (item) {
                        const previewTitle = document.querySelector('.item-title');
                        if (previewTitle) {
                            previewTitle.textContent = item.title || i18n.t('noTitle');
                        }
                    }
                }
            } catch (e) {
                // 捕获任何错误，防止函数失败影响整个页面
                console.error('Error in ensureUIConsistency:', e);
            }
        }

        // 重新渲染所有内容
        function rerenderAll() {
            // 渲染tier列表
            renderTiersList();
            // 渲染item网格
            renderItemsGrid();
            // 渲染item预览
            renderItemPreview();
            // 重置所有图片
            resetAllImages();
            // 设置拖放
            setupMainDragDrop();
            // 设置颜色选择器事件
            setupColorBoxEvents();
            // 设置跳过按钮事件
            setupSkipBtn();
            
            // 确保UI一致性
            setTimeout(ensureUIConsistency, 50);
        }

        // 绑定item点击事件
        function bindItemClickEvents() {
            // items-grid点击切换预览
            document.querySelectorAll('.items-grid .item-card').forEach(card => {
                card.onclick = () => {
                    // 获取卡片ID
                    const id = card.getAttribute('data-id');
                    console.log('点击卡片，ID:', id);
                    
                    // 确保ID存在于items数组中
                    const cardItem = items.find(item => String(item.id) === String(id));
                    if (!cardItem) {
                        console.error('找不到ID为', id, '的项目');
                        return;
                    }
                    
                    // 手动设置预览状态
                    previewIdx = 0; // 临时设置为0，之后会更新
                    previewMode = 'unclassified';
                    isClassifying = false; // 解锁
                    
                    // 如果是从grid中点击，清除跳过状态
                    skippedItems.delete(id);
                    console.log(`从items-grid点击，重置跳过状态，ID: ${id}`);
                    
                    // 找到项目在全局顺序中的位置
                    const orderArr = getGlobalPreviewOrder();
                    const itemIndex = orderArr.findIndex(itemId => String(itemId) === String(id));
                    
                    if (itemIndex !== -1) {
                        previewIdx = itemIndex;
                        console.log('设置预览索引为:', previewIdx);
                    } else {
                        console.log('项目不在全局预览序列中，尝试添加:', id);
                        // 强制将项目加入到未分类列表（如果不存在）
                        if (!unclassifiedItems.includes(id) && !unclassifiedItems.some(uid => String(uid) === String(id))) {
                            unclassifiedItems.push(id);
                            console.log('将项目添加到未分类列表:', id);
                        }
                        
                        // 重新计算预览索引
                        const newOrderArr = getGlobalPreviewOrder();
                        const newIndex = newOrderArr.findIndex(itemId => String(itemId) === String(id));
                        
                        if (newIndex !== -1) {
                            previewIdx = newIndex;
                            console.log('重新计算后的预览索引:', previewIdx);
                        } else {
                            console.error('严重错误：即使添加到未分类列表后仍找不到项目:', id);
                            previewIdx = 0;
                        }
                    }
                    
                    // 清除预览区域中的所有现有图片
                    clearImages('.item-preview');
                    
                    // 重新渲染预览
                    renderItemPreview();
                    setupColorBoxEvents();
                    setupSkipBtn();
                    
                    console.log('预览信息:', getPreviewInfo());
                };
            });
            
            // tiers-list点击切换预览
            document.querySelectorAll('.tier-content .item-card').forEach(card => {
                card.onclick = () => {
                    // 获取卡片ID
                    const id = card.getAttribute('data-id');
                    console.log('点击tier中的卡片，ID:', id);
                    
                    // 确保ID存在于items数组中
                    const cardItem = items.find(item => String(item.id) === String(id));
                    if (!cardItem) {
                        console.error('找不到ID为', id, '的项目');
                        return;
                    }
                    
                    // 获取tier信息
                    const tierContent = card.closest('.tier-content');
                    const tier = tierContent ? tierContent.getAttribute('data-tier') : null;
                    
                    // 手动设置预览状态
                    previewIdx = 0; // 临时设置为0，之后会更新
                    previewMode = 'classified';
                    isClassifying = false; // 解锁
                    
                    // 注意：不像items-grid的点击事件，这里不清除跳过状态
                    // skippedItems.delete(id); - 这行被移除，保留跳过状态
                    
                    // 找到项目在全局顺序中的位置 - 使用getGlobalPreviewOrder而不是getFilteredPreviewOrder
                    // 即使是跳过的项目也应该能在全局顺序中找到
                    const orderArr = getGlobalPreviewOrder();
                    const itemIndex = orderArr.findIndex(itemId => String(itemId) === String(id));
                    
                    if (itemIndex !== -1) {
                        previewIdx = itemIndex;
                        console.log('设置预览索引为:', previewIdx);
                    } else {
                        console.log('项目不在全局预览序列中，尝试修复:', id);
                        // 确保项目在classifiedItems中
                        const existingItem = classifiedItems.find(ci => String(ci.id) === String(id));
                        if (!existingItem && tier) {
                            classifiedItems.push({ 
                                id,
                                tier, 
                                order: getTierMaxOrder(tier) + 1 
                            });
                            console.log('将项目添加到已分类列表:', id, '级别:', tier);
                        }
                        
                        // 确保项目不在未分类列表中
                        unclassifiedItems = unclassifiedItems.filter(itemId => String(itemId) !== String(id));
                        
                        // 重新计算预览索引
                        const newOrderArr = getGlobalPreviewOrder();
                        const newIndex = newOrderArr.findIndex(itemId => String(itemId) === String(id));
                        
                        if (newIndex !== -1) {
                            previewIdx = newIndex;
                            console.log('重新计算后的预览索引:', previewIdx);
                        } else {
                            console.error('严重错误：即使添加到已分类列表后仍找不到项目:', id);
                            previewIdx = 0;
                        }
                    }
                    
                    // 清除预览区域中的所有现有图片
                    clearImages('.item-preview');
                    
                    // 重新渲染预览
                    renderItemPreview();
                    setupColorBoxEvents();
                    setupSkipBtn();
                    
                    console.log('预览信息:', getPreviewInfo());
                };
            });
        }

        // 根据tier和index获取正确的order值
        function getOrderForPosition(tier, insertIndex) {
            const tierItems = classifiedItems
                .filter(ci => ci.tier === tier)
                .sort((a, b) => a.order - b.order);
            
            // 如果tier是空的
            if (tierItems.length === 0) {
                return 1;
            }
            
            // 如果要放在最前面
            if (insertIndex === 0) {
                return tierItems[0].order - 1;
            }
            
            // 如果要放在最后面
            if (insertIndex >= tierItems.length) {
                return tierItems[tierItems.length - 1].order + 1;
            }
            
            // 放在中间
            const prevOrder = tierItems[insertIndex - 1].order;
            const nextOrder = tierItems[insertIndex].order;
            return (prevOrder + nextOrder) / 2;
        }

        // 重新索引指定tier中所有items的order
        function reindexTierItems(tier) {
            const tierItems = classifiedItems
                .filter(ci => ci.tier === tier)
                .sort((a, b) => a.order - b.order);
            
            // 重新分配order值，从1开始，间隔1
            tierItems.forEach((item, index) => {
                item.order = index + 1;
            });
        }

        // 重新索引所有tier的order
        function reindexTierOrder() {
            tierManager.getTiers().forEach(tier => {
                const arr = classifiedItems.filter(ci => ci.tier === tier);
                arr.sort((a, b) => a.order - b.order);
                arr.forEach((ci, idx) => ci.order = idx + 1);
            });
        }

        // 计算放置位置
        function calculateDropPosition(e, container, items) {
            const containerRect = container.getBoundingClientRect();
            const mouseX = e.clientX - containerRect.left;
            const mouseY = e.clientY - containerRect.top;
            
            // 如果没有items，返回默认值指示放在中间
            if (items.length === 0) {
                return {
                    dropIndex: 0,
                    indicatorX: containerRect.width / 2,
                    indicatorY: Math.max(10, mouseY - 30),
                    indicatorHeight: 60,
                    targetItem: null
                };
            }
            
            // 计算每个item的位置和距离
            const itemsWithPosition = items.map(item => {
                const rect = item.getBoundingClientRect();
                const centerX = rect.left - containerRect.left + rect.width / 2;
                const centerY = rect.top - containerRect.top + rect.height / 2;
                const distance = Math.sqrt(
                    Math.pow(mouseX - centerX, 2) + 
                    Math.pow(mouseY - centerY, 2)
                );
                return { 
                    item, 
                    rect,
                    centerX, 
                    centerY, 
                    distance,
                    left: rect.left - containerRect.left,
                    right: rect.right - containerRect.left,
                    top: rect.top - containerRect.top,
                    bottom: rect.bottom - containerRect.top,
                    width: rect.width,
                    height: rect.height
                };
            });
            
            // 按距离排序
            itemsWithPosition.sort((a, b) => a.distance - b.distance);
            
            // 找到最近的项目
            const closest = itemsWithPosition[0];
            
            if (!closest) {
                return {
                    dropIndex: 0,
                    indicatorX: 5,
                    indicatorY: Math.max(10, mouseY - 30),
                    indicatorHeight: 60,
                    targetItem: null
                };
            }
            
            // 确定鼠标相对于最近item的位置
            const isLeft = mouseX < closest.centerX;
            
            // 寻找同一行的所有项目
            const ROW_THRESHOLD = closest.height * 0.7;
            const sameRowItems = itemsWithPosition.filter(item => 
                Math.abs(item.centerY - closest.centerY) < ROW_THRESHOLD
            ).sort((a, b) => a.left - b.left);
            
            // 找出当前项目在排好序的行中的索引
            const currentIndexInRow = sameRowItems.findIndex(item => item.item === closest.item);
            const currentIndexInItems = Array.from(items).indexOf(closest.item);
            
            // 确定放在左边还是右边
            if (isLeft) {
                // 放在左边
                return {
                    dropIndex: currentIndexInItems,
                    indicatorX: closest.left - 2,
                    indicatorY: closest.top,
                    indicatorHeight: closest.height,
                    targetItem: closest.item
                };
            } else {
                // 放在右边
                return {
                    dropIndex: currentIndexInItems + 1,
                    indicatorX: closest.right + 2,
                    indicatorY: closest.top,
                    indicatorHeight: closest.height,
                    targetItem: closest.item
                };
            }
        }

        // 首次渲染
        rerenderAll();

        // 设置按钮点击事件
        document.getElementById('setting-btn').addEventListener('click', () => {
            // 先显示模态窗口
            document.getElementById('modal-overlay').style.display = 'block';
            document.getElementById('setting-modal').style.display = 'block';
            
            // 更新标题输入框，反映main-title的当前值
            const mainTitle = document.getElementById('main-title');
            const titleInput = document.getElementById('title-input');
            if (mainTitle && titleInput) {
                // 从localStorage加载保存的标题
                const savedTitle = localStorage.getItem('tiermaker-custom-title');
                if (savedTitle) {
                    mainTitle.textContent = savedTitle;
                    titleInput.value = savedTitle;
                } else {
                    titleInput.value = mainTitle.textContent.trim();
                }
                
                // 移除现有的事件监听器（如果有）
                titleInput.removeEventListener('input', titleInput._titleInputHandler);
                
                // 创建新的事件处理函数
                titleInput._titleInputHandler = function(e) {
                    const newTitle = e.target.value;
                    mainTitle.textContent = newTitle;
                    localStorage.setItem('tiermaker-custom-title', newTitle);
                    console.log('Title saved:', newTitle);
                };
                
                // 添加事件监听器
                titleInput.addEventListener('input', titleInput._titleInputHandler);
            }
            
            // 从本地存储加载创建者名称
            const creatorNameInput = document.getElementById('creator-name-input');
            if (creatorNameInput) {
                const savedCreatorName = localStorage.getItem('tiermaker-creator-name') || '';
                creatorNameInput.value = savedCreatorName;

                // 添加实时保存功能
                creatorNameInput.addEventListener('input', function(e) {
                    const newName = e.target.value.trim();
                    localStorage.setItem('tiermaker-creator-name', newName);
                    console.log('Creator name saved:', newName);
                    
                    // 立即重新渲染预览以更新水印
                    if (document.getElementById('share-modal').style.display === 'block') {
                        generateTierListPreview();
                    }
                });
            }
            
            // tierManager.js已提供reorderTiers方法，不需要再添加
            // addTierManagerReorderMethod();
            
            // 确保选择信息存在
            ensureSelectionInfoExists();
            
            // 渲染设置
            renderTierSettings();
            
            // 翻译设置面板
            i18n.translateSettingsModal();
            
            // 修复标题
            fixSettingsLabels();
            
            // 强制显示元素
            setTimeout(() => {
                forceDisplaySettingsElements();
                forceUpdateItemsCount();
            }, 100);
        });

        document.getElementById('setting-btn2').addEventListener('click', () => {
            // 先显示模态窗口
            document.getElementById('modal-overlay').style.display = 'block';
            document.getElementById('setting-modal').style.display = 'block';
            
            // 更新标题输入框，反映main-title的当前值
            const mainTitle = document.getElementById('main-title');
            const titleInput = document.getElementById('title-input');
            if (mainTitle && titleInput) {
                // 从localStorage加载保存的标题
                const savedTitle = localStorage.getItem('tiermaker-custom-title');
                if (savedTitle) {
                    mainTitle.textContent = savedTitle;
                    titleInput.value = savedTitle;
                } else {
                    titleInput.value = mainTitle.textContent.trim();
                }
                
                // 移除现有的事件监听器（如果有）
                titleInput.removeEventListener('input', titleInput._titleInputHandler);
                
                // 创建新的事件处理函数
                titleInput._titleInputHandler = function(e) {
                    const newTitle = e.target.value;
                    mainTitle.textContent = newTitle;
                    localStorage.setItem('tiermaker-custom-title', newTitle);
                    console.log('Title saved:', newTitle);
                };
                
                // 添加事件监听器
                titleInput.addEventListener('input', titleInput._titleInputHandler);
            }
            
            // 从本地存储加载创建者名称
            const creatorNameInput = document.getElementById('creator-name-input');
            if (creatorNameInput) {
                const savedCreatorName = localStorage.getItem('tiermaker-creator-name') || '';
                creatorNameInput.value = savedCreatorName;
            }
            
            // tierManager.js已提供reorderTiers方法，不需要再添加
            // addTierManagerReorderMethod();
            
            // 确保选择信息存在
            ensureSelectionInfoExists();
            
            // 渲染设置
            renderTierSettings();
            
            // 翻译设置面板
            i18n.translateSettingsModal();
            
            // 修复标题
            fixSettingsLabels();
            
            // 强制显示元素
            setTimeout(() => {
                forceDisplaySettingsElements();
                forceUpdateItemsCount();
            }, 100);
        });

        document.getElementById('modal-overlay').addEventListener('click', () => {
            // 更新items计数，确保在下次打开时显示正确
            forceUpdateItemsCount();
            
            // 关闭模态窗口
            document.getElementById('modal-overlay').style.display = 'none';
            document.querySelectorAll('.modal').forEach(modal => {
                modal.style.display = 'none';
            });
        });

        // 渲染tier设置，修复删除按钮功能及颜色更新问题
        function renderTierSettings() {
            const tiersTableBody = document.getElementById('tier-settings-body');
            tiersTableBody.innerHTML = '';
            
            // 设置表格可排序
            const sortable = new Sortable(tiersTableBody, {
                handle: '.tier-handle',
                animation: 150,
                onEnd: function(evt) {
                    // 获取新的排序顺序
            const tiers = tierManager.getTiers();
                    const newTiers = Array.from(tiersTableBody.querySelectorAll('tr')).map(row => {
                        const tierCell = row.querySelector('td:nth-child(2)');
                        const tierName = tierCell.getAttribute('data-tier');
                        return tierName;
                    }).filter(Boolean);
                    
                    // 更新tierManager中的顺序
                    tierManager.reorderTiers(newTiers);
                    
                    // 立即保存到localStorage
                    localStorage.setItem('tiermaker-tiers', JSON.stringify({
                        tiers: tierManager.getTiers(),
                        tierNames: tierManager.tierNames,
                        tierLimits: tierManager.tierLimits
                    }));
                    
                    // 立即重新渲染主界面
                    rerenderAll();
                    
                    // 手动更新设置面板中所有tier的颜色
                    document.querySelectorAll('#tier-settings-body tr').forEach(row => {
                        const tier = row.getAttribute('data-tier');
                        if (!tier) return;
                        
                        // 找到颜色预览元素
                        const colorPreview = row.querySelector('.tier-color-preview');
                        if (colorPreview) {
                            // 更新颜色
                            const tierColor = tierManager.getTierColor(tier);
                            colorPreview.style.backgroundColor = tierColor;
                        }
                    });
                }
            });
            
            // 为每个tier创建对应的行，并按照当前顺序显示
            tierManager.getTiers().forEach((tier, index) => {
                const row = document.createElement('tr');
                row.setAttribute('data-tier', tier);
                
                // 排序手柄
                const handleCell = document.createElement('td');
                handleCell.innerHTML = '<span style="display: inline-block; font-size: 20px; color: #999; cursor: move;">≡</span>';
                handleCell.className = 'tier-handle';
                handleCell.style.display = 'table-cell'; // 强制显示
                handleCell.style.cursor = 'move';
                row.appendChild(handleCell);
                
                // Tier - 只显示颜色，不显示字母
                const tierCell = document.createElement('td');
                tierCell.setAttribute('data-tier', tier); // 存储tier值到属性中，用于排序
                const colorPreview = document.createElement('span');
                colorPreview.className = 'tier-color-preview';
                
                // 根据当前位置获取颜色，而不是使用tier本身的颜色
                const tierColor = tierManager.getTierColor(tier);
                colorPreview.style.backgroundColor = tierColor;
                colorPreview.style.width = '30px';
                colorPreview.style.height = '30px';
                colorPreview.style.display = 'inline-block';
                
                tierCell.appendChild(colorPreview);
                // 不再添加字母文本
                // tierCell.appendChild(document.createTextNode(tier));
                row.appendChild(tierCell);
                
                // 显示名称
                const nameCell = document.createElement('td');
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'tier-input';
                nameInput.value = tierManager.getTierName(tier);
                nameInput.onchange = e => {
                    // 更新tier名称
                    tierManager.setTierName(tier, e.target.value);
                    
                    // 立即保存到localStorage
                    localStorage.setItem('tiermaker-tiers', JSON.stringify({
                        tiers: tierManager.getTiers(),
                        tierNames: tierManager.tierNames,
                        tierLimits: tierManager.tierLimits
                    }));
                    
                    // 立即重新渲染主界面
                    rerenderAll();
                };
                nameCell.appendChild(nameInput);
                row.appendChild(nameCell);
                
                // 数量限制
                const limitCell = document.createElement('td');
                const limitInput = document.createElement('input');
                limitInput.type = 'number';
                limitInput.className = 'tier-limit-input';
                limitInput.min = '0';
                limitInput.value = tierManager.getTierLimit(tier) || '';
                limitInput.placeholder = 'Infinite';
                limitInput.onchange = e => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    
                    // 更新tier限制
                    tierManager.setTierLimit(tier, val);
                    
                    // 立即保存到localStorage
                    localStorage.setItem('tiermaker-tiers', JSON.stringify({
                        tiers: tierManager.getTiers(),
                        tierNames: tierManager.tierNames,
                        tierLimits: tierManager.tierLimits
                    }));
                    
                    // 立即重新渲染主界面
                    rerenderAll();
                };
                limitCell.appendChild(limitInput);
                row.appendChild(limitCell);
                
                // 删除按钮 - 直接使用普通按钮而不是样式按钮
                const actionCell = document.createElement('td');
                actionCell.style.textAlign = 'center';
                if (tierManager.getTiers().length > 1) {
                    // 创建一个标准按钮，确保可以被点击
                    const deleteBtn = document.createElement('button');
                    deleteBtn.type = 'button';
                    deleteBtn.innerHTML = '×';
                    deleteBtn.className = 'tier-delete-btn';
                    deleteBtn.style.color = '#ff3333';
                    deleteBtn.style.fontSize = '24px';
                    deleteBtn.style.fontWeight = 'bold';
                    deleteBtn.style.cursor = 'pointer';
                    deleteBtn.style.display = 'inline-block';
                    deleteBtn.style.width = '30px';
                    deleteBtn.style.height = '30px';
                    deleteBtn.style.lineHeight = '20px';
                    deleteBtn.style.textAlign = 'center';
                    deleteBtn.style.padding = '0';
                    deleteBtn.style.background = 'none';
                    deleteBtn.style.border = 'none';
                    deleteBtn.style.outline = 'none';
                    
                    // 为删除按钮添加点击事件 - 不需要确认，直接删除
                    deleteBtn.addEventListener('click', function(e) {
                        // 阻止冒泡
                        e.preventDefault();
                        e.stopPropagation();
                        
                        console.log('删除按钮被点击: 直接删除tier', tier);
                        
                        // 先找出该tier中的所有items
                        const tierItems = classifiedItems.filter(ci => ci.tier === tier);
                        console.log(`找到${tierItems.length}个需要移回未分类区域的items`);
                        
                        // 记录这些items的ID
                        const itemsToUnclassify = tierItems.map(item => item.id);
                        
                        // 执行删除操作
                        if (tierManager.removeTier(tier)) {
                            console.log('tier已被成功删除');
                            
                            // 将tier中的所有items移回到未分类状态
                            itemsToUnclassify.forEach(itemId => {
                                // 从classifiedItems中移除 - 使用字符串比较
                                classifiedItems = classifiedItems.filter(ci => !(String(ci.id) === String(itemId) && ci.tier === tier));
                                
                                // 添加到未分类区域
                                if (!unclassifiedItems.includes(itemId)) {
                                    unclassifiedItems.push(itemId);
                                    console.log(`Item ${itemId} 已移回未分类区域`);
                                }
                            });
                            
                            // 保存到localStorage
                            localStorage.setItem('tiermaker-tiers', JSON.stringify({
                                tiers: tierManager.getTiers(),
                                tierNames: tierManager.tierNames,
                                tierLimits: tierManager.tierLimits
                            }));
                            
                            // 保存items状态到localStorage
                            saveItemsToLocalStorage();
                            
                            // 重新渲染设置面板
                            renderTierSettings();
                            
                            // 重新渲染所有内容
                            rerenderAll();
                        } else {
                            console.error('删除tier失败');
                            alert('删除失败，请确保至少保留一个tier');
                        }
                    });
                    
                    actionCell.appendChild(deleteBtn);
                }
                row.appendChild(actionCell);
                
                tiersTableBody.appendChild(row);
            });
        }

        // 添加新tier
        document.getElementById('add-tier-btn').addEventListener('click', () => {
            // 直接使用tierManager的addTier方法，该方法会自动选择合适的下一个tier字母
            if (tierManager.addTier()) {
                console.log('成功添加新tier');
                
                // 保存到localStorage - tierManager.addTier()已经保存，这里不需要重复
                
                // 重新渲染设置面板中的tier列表
            renderTierSettings();
                
                // 重新渲染主界面，使变更立即生效
                rerenderAll();
                
                // 移除不必要的成功提示消息
            } else {
                console.error('添加tier失败，可能已达到最大数量限制');
            }
        });

        // 处理确认对话框
        function handleConfirmDialog(message, callback) {
            if (confirm(message)) {
                callback();
            }
        }
        
        // 重置为默认tiers - 自定义重置逻辑
        document.getElementById('reset-tiers-btn').addEventListener('click', () => {
            console.log('重置tiers按钮被点击 - 使用自定义重置逻辑');
            
            // 默认的6个tiers
            const defaultTiers = ['S', 'A', 'B', 'C', 'D', 'F'];
            
            // 获取当前所有tiers
            const currentTiers = tierManager.getTiers();
            console.log('当前tiers:', currentTiers);
            
            // 找出要移除的tiers（超过6个的部分）
            const tiersToRemove = currentTiers.length > 6 ? currentTiers.slice(6) : [];
            console.log('要移除的tiers:', tiersToRemove);
            
            // 收集所有要移除的tiers中的items
            const itemsToUnclassify = [];
            tiersToRemove.forEach(tier => {
                const tierItems = classifiedItems.filter(ci => ci.tier === tier);
                const tierItemIds = tierItems.map(item => item.id);
                itemsToUnclassify.push(...tierItemIds);
                console.log(`Tier ${tier} 中找到 ${tierItemIds.length} 个要移回未分类区域的items`);
            });
            
            // 移除多余的tiers
            tiersToRemove.forEach(tier => {
                tierManager.removeTier(tier);
                console.log(`已移除tier: ${tier}`);
            });
            
            // 保留前6个tiers，并按顺序重命名为默认名称
            const tiersToKeep = currentTiers.slice(0, Math.min(6, currentTiers.length));
            console.log('保留的tiers:', tiersToKeep);
            
            // 如果当前tiers少于6个，需要添加缺少的tiers
            if (tiersToKeep.length < 6) {
                for (let i = tiersToKeep.length; i < 6; i++) {
                    tierManager.addSpecificTier(defaultTiers[i]);
                    console.log(`添加缺少的tier: ${defaultTiers[i]}`);
                }
            }
            
            // 重新获取当前tiers（可能已添加了缺少的tiers）
            const updatedTiers = tierManager.getTiers().slice(0, 6);
            
            // 重新排序前6个tiers为默认顺序
            tierManager.reorderTiers(defaultTiers);
            console.log('已重新排序tiers为默认顺序');
            
            // 恢复默认tier名称
            defaultTiers.forEach(tier => {
                tierManager.setTierName(tier, tier);
                console.log(`已将tier ${tier} 的名称恢复为默认`);
            });
            
            // 将被移除tiers中的items移回到未分类状态
            itemsToUnclassify.forEach(itemId => {
                // 从classifiedItems中移除 - 使用字符串比较
                classifiedItems = classifiedItems.filter(ci => {
                    // 只移除在被删除tier中的items
                    return !(String(ci.id) === String(itemId) && tiersToRemove.includes(ci.tier));
                });
                
                // 添加到未分类区域
                if (!unclassifiedItems.includes(itemId)) {
                    unclassifiedItems.push(itemId);
                    console.log(`Item ${itemId} 已移回未分类区域`);
                }
            });
                
                // 保存到localStorage
                localStorage.setItem('tiermaker-tiers', JSON.stringify({
                    tiers: tierManager.getTiers(),
                    tierNames: tierManager.tierNames,
                    tierLimits: tierManager.tierLimits
                }));
                
                // 保存items状态到localStorage
                saveItemsToLocalStorage();
                
                // 重新渲染设置
                renderTierSettings();
                
                // 重新渲染所有内容
                rerenderAll();
            
            console.log('自定义tier重置完成');
        });
        
        // 清除所有项目
        function clearAllItems() {
            // 清空数据
            items.length = 0;
            localItems.length = 0;
            unclassifiedItems.length = 0;
            classifiedItems.length = 0;
            skippedItems.clear();
            
            // 重置预览索引
            previewIdx = 0;
            previewMode = 'unclassified';
            previewSelectedTier = null;
            
            // 保存到本地存储
            saveItemsToLocalStorage();
            
            // 更新计数 - 确保即使在设置对话框中也更新
            updateItemsCount();
            forceUpdateItemsCount();
            
            // 重新渲染
            rerenderAll();
            
            // 显示成功消息
            showSuccessMessage(i18n.t('itemsCleared'));
        }
        
        // 显示成功消息
        function showSuccessMessage(message) {
            const successMessage = document.createElement('div');
            successMessage.className = 'success-message';
            successMessage.textContent = message;
            
            // 设置样式
            successMessage.style.position = 'fixed';
            successMessage.style.bottom = '20px';
            successMessage.style.left = '50%';
            successMessage.style.transform = 'translateX(-50%)';
            successMessage.style.backgroundColor = '#4CAF50';
            successMessage.style.color = 'white';
            successMessage.style.padding = '10px 20px';
            successMessage.style.borderRadius = '4px';
            successMessage.style.zIndex = '1000';
            
            document.body.appendChild(successMessage);
            
            // 3秒后消失
            setTimeout(() => {
                successMessage.style.opacity = '0';
                successMessage.style.transition = 'opacity 0.5s ease';
                
                // 动画完成后移除元素
                setTimeout(() => {
                    document.body.removeChild(successMessage);
                }, 500);
            }, 3000);
        }

        // 保存设置
        document.getElementById('save-settings-btn').addEventListener('click', () => {
            // 更新标题 - 不仅更新localStorage，还直接更新DOM
            const titleInput = document.getElementById('title-input');
            if (titleInput && titleInput.value) {
                // 更新main-title元素
                const mainTitle = document.getElementById('main-title');
                if (mainTitle) {
                    mainTitle.textContent = titleInput.value;
                }
                localStorage.setItem('tiermaker-custom-title', titleInput.value);
            }
            
            // 应用图片比例设置
            const ratioSelect = document.getElementById('image-ratio-select');
            if (ratioSelect) {
                applyImageRatio(ratioSelect.value);
            }
            
            // 关闭模态框
            document.getElementById('modal-overlay').style.display = 'none';
            document.getElementById('setting-modal').style.display = 'none';
            
            // 重新渲染并应用当前语言
            rerenderAll();
            i18n.applyTranslations();
            
            // 简单直接的UI一致性检查 - 不使用MutationObserver和多个setTimeout
            ensureUIConsistency();
            
            // 单个延迟确保UI一致性和正确显示
            setTimeout(() => {
                // 强制更新项目计数和确保items-count显示正确
                updateItemsCount();
                forceUpdateItemsCount();
                
                // 确保选择信息元素存在且可见
                const selectionInfo = ensureSelectionInfoExists();
                if (selectionInfo) {
                    selectionInfo.style.display = 'inline-block';
                    selectionInfo.classList.add('forced-selection-info');
                }
                
                // 更新category-title中的items-count
                const categoryTitle = document.querySelector('.category-title');
                if (categoryTitle) {
                    const validUnclassifiedCount = unclassifiedItems.filter(id => !skippedItems.has(id)).length;
                    let countSpan = categoryTitle.querySelector('.items-count');
                    if (!countSpan) {
                        countSpan = document.createElement('span');
                        countSpan.className = 'items-count';
                        categoryTitle.appendChild(document.createTextNode(' '));
                        categoryTitle.appendChild(countSpan);
                    }
                    countSpan.textContent = `(${validUnclassifiedCount}/${items.length})`;
                }
                
                // 恢复正确的预览标题
                const { previewId } = getPreviewInfo();
                if (previewId) {
                    const item = items.find(i => String(i.id) === String(previewId));
                    if (item) {
                        const previewTitle = document.querySelector('.item-title');
                        if (previewTitle) {
                            previewTitle.textContent = item.title || i18n.t('noTitle');
                        }
                    }
                }
                
                // 重新绑定必要的事件处理程序
                bindItemClickEvents();
                setupColorBoxEvents();
                setupSkipBtn();
            }, 200);
        });

        // 添加title-input的实时同步功能
        document.addEventListener('DOMContentLoaded', function() {
            const titleInput = document.getElementById('title-input');
            if (titleInput) {
                titleInput.addEventListener('input', function(e) {
                    const mainTitle = document.getElementById('main-title');
                    if (mainTitle) {
                        mainTitle.textContent = e.target.value;
                    }
                });
            }
        });

        // 绑定color-box点击事件
        function setupColorBoxEvents() {
            document.querySelectorAll('.color-box').forEach((box, idx) => {
                const tier = tierManager.getTiers()[idx % tierManager.getTiers().length];
                
                // Skip disabled boxes
                if (box.getAttribute('data-disabled') === 'true') return;
                
                box.onclick = e => {
                    e.preventDefault();
                    if (isClassifying) return;
                    
                    const { previewId, previewMode, previewTier } = getPreviewInfo();
                    if (!previewId) return;
                    
                    // 如果是已分类项目，直接分类到新tier
                    if (previewMode === 'classified') {
                        isClassifying = true;
                        disableColorBoxes();
                        const result = changeCurrentItemTier(tier);
                        if (result === false) {
                            isClassifying = false;
                            enableColorBoxes();
                        }
                            return;
                    }
                    
                    // 未分类项目，第一次点击高亮，第二次点击确认
                            if (previewSelectedTier === tier) {
                        // 第二次点击同一个tier，确认分类
                        isClassifying = true;
                        disableColorBoxes();
                        const result = classifyCurrentItem(tier);
                        previewSelectedTier = null;
                        if (result === false) {
                            isClassifying = false;
                            enableColorBoxes();
                        }
                            } else {
                        // 第一次点击，或点击了不同的tier，高亮当前选择
                                previewSelectedTier = tier;
                        // 重新渲染，显示高亮
                                renderItemPreview();
                    }
                };
            });
        }

        // 绑定skip-btn点击事件
        function setupSkipBtn() {
            const skipBtn = document.querySelector('.skip-btn');
            if (skipBtn) {
                skipBtn.onclick = () => {
                    if (isClassifying) return;
                    
                    // 获取当前预览模式 - 每次点击时获取最新状态，不使用destructuring
                    const currentPreviewMode = getPreviewInfo().previewMode;
                    
                    console.log('Skip button clicked, previewMode:', currentPreviewMode);
                    isClassifying = true;
                    
                    if (currentPreviewMode === 'classified') {
                        unclassifyCurrentItem(); // 这个函数内部已经添加了saveItemsToLocalStorage
                        
                        // 增加一个额外的保存操作，确保状态被保存
                        setTimeout(() => {
                            console.log('额外保存操作，以确保取消分类状态被正确保存');
                            saveItemsToLocalStorage();
                            
                            // 立即重新渲染，确保UI与数据状态一致
                            rerenderAll();
                        }, 200);
                    } else {
                        gotoNextPreview(true); // true表示跳过
                    }
                    
                    // 检查是否没有未跳过且未分类的项目，如果是，直接显示完成状态
                    const unclassifiedUnskipped = unclassifiedItems.filter(id => !skippedItems.has(id));
                    if (unclassifiedUnskipped.length === 0) {
                        console.log('没有未跳过且未分类的项目，显示完成状态');
                        previewMode = 'completed';
                        renderItemPreview();
                    }
                    
                    // 更新按钮文本为当前语言
                    setTimeout(() => {
                        // 重新获取当前预览模式
                        const { previewMode: updatedPreviewMode } = getPreviewInfo();
                        skipBtn.textContent = updatedPreviewMode === 'classified' ? i18n.t('cancel') : i18n.t('skip');
                    }, 50);
                };
            }
            
            const nextBtn = document.querySelector('.next-btn');
            if (nextBtn) {
                nextBtn.onclick = () => {
                    if (isClassifying) return;
                    isClassifying = true;
                    gotoNextPreview();
                    
                    // 更新按钮文本为当前语言
                    nextBtn.textContent = i18n.t('next');
                };
            }
        }

        // 计算指定tier下的最大order值
        function getTierMaxOrder(tier) {
            const tierItems = classifiedItems.filter(ci => ci.tier === tier);
            if (tierItems.length === 0) return 0;
            
            return Math.max(...tierItems.map(item => item.order || 0));
        }

        // 初始化项目列表
        function initItems() {
            // 确保localItems是一个空数组
            localItems = [];
            items = [];
            unclassifiedItems = [];
            classifiedItems = [];
            
            // 不要在这里清空skippedItems，而是等待从localStorage或IndexedDB加载
            // skippedItems = new Set(); // 删除这行代码，防止初始化时清空跳过状态
            console.log('初始化时保留现有跳过状态:', Array.from(skippedItems));
            
            // 首先尝试从IndexedDB加载
            console.log('开始从IndexedDB加载数据...');
            
            dbManager.loadItems().then(loadedItems => {
                console.log(`成功从IndexedDB加载了 ${loadedItems.length} 个项目`);
                
                // 更新localItems和items
                localItems = loadedItems;
                items = [...loadedItems];
                
                // 加载分类信息
                return dbManager.loadSettings(['classified-items', 'unclassified-items', 'skipped-items']);
            }).then(settings => {
                // 更新分类信息
                if (settings['classified-items']) {
                    classifiedItems = settings['classified-items'];
                    console.log(`加载了 ${classifiedItems.length} 个已分类项目`);
                }
                
                if (settings['unclassified-items']) {
                    unclassifiedItems = settings['unclassified-items'];
                    console.log(`加载了 ${unclassifiedItems.length} 个未分类项目`);
                }
                
                if (settings['skipped-items']) {
                    skippedItems = new Set(settings['skipped-items']);
                    console.log(`加载了 ${skippedItems.size} 个已跳过项目`);
                } else {
                    // 从localStorage尝试加载skippedItems
                    loadSkippedItems();
                    console.log(`从localStorage加载了 ${skippedItems.size} 个已跳过项目`);
                }
                
                // 如果没有未分类项目，但有项目，初始化未分类列表
                if (unclassifiedItems.length === 0 && items.length > 0) {
                    // 获取已分类项目的ID集合
                    const classifiedIds = new Set(classifiedItems.map(ci => ci.id));
                    
                    // 添加未在已分类列表中的项目到未分类列表
                    items.forEach(item => {
                        if (!classifiedIds.has(item.id)) {
                            unclassifiedItems.push(item.id);
                        }
                    });
                    console.log(`自动添加 ${unclassifiedItems.length} 个项目到未分类列表`);
                }
                
                // 确保previewIdx设为0，显示第一个项目
                previewIdx = 0;
                
                // 重要：明确设置previewMode为unclassified，如果有未分类项目
                if (unclassifiedItems.length > 0) {
                    previewMode = 'unclassified';
                    
                    // 获取全局顺序，并确保previewIdx指向第一个未分类项目
                    const globalOrder = getGlobalPreviewOrder();
                    const firstUnclassified = globalOrder.find(id => unclassifiedItems.includes(id));
                    if (firstUnclassified) {
                        previewIdx = globalOrder.indexOf(firstUnclassified);
                        console.log(`初始化: 设置预览索引为 ${previewIdx}，对应第一个未分类项目ID: ${firstUnclassified}`);
                    }
                } else {
                    previewMode = 'classified';
                }
                
                // 检查IndexedDB存储空间
                return dbManager.checkStorage();
            }).then(storageInfo => {
                // 显示存储使用情况
                if (storageInfo.quota > 0) {
                    console.log(`IndexedDB存储空间: ${(storageInfo.usage/1024/1024).toFixed(2)}MB / ${(storageInfo.quota/1024/1024).toFixed(2)}MB (${storageInfo.usedPercentage.toFixed(2)}%)`);
                }
                
                // 重新渲染
        rerenderAll();
                updateItemsCount();
            }).catch(error => {
                console.warn('从IndexedDB加载失败，尝试从localStorage加载:', error);
                
                // 回退到localStorage加载
                try {
                    // 尝试从localStorage加载items
                    const serializedItems = localStorage.getItem('tiermaker-items');
                    if (serializedItems) {
                        localItems = JSON.parse(serializedItems);
                        items = [...localItems];
                        console.log(`从localStorage加载了 ${items.length} 个项目`);
                    } else {
                        console.log('localStorage中没有保存的项目');
                    }
                    
                    // 加载分类状态
                    const classifiedData = localStorage.getItem('tiermaker-classified-items');
                    if (classifiedData) {
                        classifiedItems = JSON.parse(classifiedData);
                        console.log(`从localStorage加载了 ${classifiedItems.length} 个已分类项目`);
                    }
                    
                    const unclassifiedData = localStorage.getItem('tiermaker-unclassified-items');
                    if (unclassifiedData) {
                        unclassifiedItems = JSON.parse(unclassifiedData);
                        console.log(`从localStorage加载了 ${unclassifiedItems.length} 个未分类项目`);
                    }
                    
                    // 从localStorage加载跳过状态
                    loadSkippedItems();
                    console.log(`从localStorage加载了 ${skippedItems.size} 个已跳过项目`);
                    
                    // 如果没有未分类项目但有项目，自动添加到未分类列表
                    if (unclassifiedItems.length === 0 && items.length > 0) {
                        // 获取已分类项目的ID集合
                        const classifiedIds = new Set(classifiedItems.map(ci => ci.id));
                        
                        // 添加未在已分类列表中的项目到未分类列表
                        items.forEach(item => {
                            if (!classifiedIds.has(item.id)) {
                                unclassifiedItems.push(item.id);
                            }
                        });
                        console.log(`自动添加 ${unclassifiedItems.length} 个项目到未分类列表`);
                    }
                    
                    // 确保previewIdx设为0，预览第一个未分类项目
                    previewIdx = 0;
                    
                    // 重要：明确设置previewMode为unclassified，如果有未分类项目
                    if (unclassifiedItems.length > 0) {
                        previewMode = 'unclassified';
                        
                        // 获取全局顺序，并确保previewIdx指向第一个未分类项目
                        const globalOrder = getGlobalPreviewOrder();
                        const firstUnclassified = globalOrder.find(id => unclassifiedItems.includes(id));
                        if (firstUnclassified) {
                            previewIdx = globalOrder.indexOf(firstUnclassified);
                            console.log(`初始化: 设置预览索引为 ${previewIdx}，对应第一个未分类项目ID: ${firstUnclassified}`);
                        }
                    } else {
                        previewMode = 'classified';
                    }
                    
                    // 重新渲染
                rerenderAll();
                    updateItemsCount();
                } catch (e) {
                    console.error('从localStorage加载项目时出错:', e);
                }
            });
        }

        // 保存items到本地存储
        function saveItemsToLocalStorage() {
            try {
                // 首先使用IndexedDB保存数据
                const settings = {
                    'classified-items': classifiedItems,
                    'unclassified-items': unclassifiedItems,
                    'skipped-items': Array.from(skippedItems)
                };
                
                dbManager.saveItems(localItems, settings).then(() => {
                    console.log('成功使用IndexedDB保存数据');
                }).catch(error => {
                    console.error('使用IndexedDB保存失败，回退到localStorage:', error);
                    
                    // 回退到localStorage保存方法
                    try {
                        // 尝试使用标准方法保存
                        const serializedItems = JSON.stringify(localItems);
                        
                        try {
                            localStorage.setItem('tiermaker-items', serializedItems);
                        } catch (e) {
                            // 如果超出配额，显示警告但不阻止程序运行
                            console.warn('保存items到localStorage失败，可能是超出了存储限制', e);
                            
                            // 保存当前项目ID和状态，即使图片数据丢失
                            saveItemsStateOnly();
                            
                            // 如果是存储配额错误，向用户显示提示
                            if (e.name === 'QuotaExceededError') {
                                console.error('localStorage存储空间已满');
                            }
                        }
                    } catch (e) {
                        console.error('保存items时出错:', e);
                    }
                });
            } catch (e) {
                console.error('保存过程中出错:', e);
            }
        }
        
        // 只保存项目状态，不包括大型图片数据
        function saveItemsStateOnly() {
            try {
                // 创建一个精简版的items数组，只包含id和title
                const minimalItems = localItems.map(item => {
                    return {
                        id: item.id,
                        title: item.title
                    };
                });
                
                // 保存精简版数据
                localStorage.setItem('tiermaker-items-minimal', JSON.stringify(minimalItems));
                
                // 保存分类和跳过状态
                localStorage.setItem('tiermaker-classified-items', JSON.stringify(classifiedItems));
                localStorage.setItem('tiermaker-unclassified-items', JSON.stringify(unclassifiedItems));
                localStorage.setItem('tiermaker-skipped-items', JSON.stringify(Array.from(skippedItems)));
                
                console.log('已保存项目状态（不含图片数据）');
            } catch (e) {
                console.error('保存项目状态时出错:', e);
            }
        }

        // 更新items计数显示
        function updateItemsCount() {
            const itemsCountEl = document.getElementById('items-count');
            if (itemsCountEl) {
                itemsCountEl.textContent = items.length;
            }
            
            // 更新显示计数的信息
            const selectionInfo = document.querySelector('.selection-info');
            if (selectionInfo) {
                // 使用与forceUpdateItemsCount相同的格式显示项目数量
                const selectedItemsText = i18n.t('selectedItems');
                selectionInfo.innerHTML = `${selectedItemsText} (${items.length})`;
                
                // 确保元素可见
                selectionInfo.style.display = 'inline-block';
                selectionInfo.style.minWidth = '150px';
                selectionInfo.style.marginLeft = '10px'; // 添加左边距，确保在按钮右侧显示
                selectionInfo.style.color = 'var(--text-color)'; // 确保文本颜色正确
                selectionInfo.style.verticalAlign = 'middle'; // 垂直对齐
            }
            
            // 更新Items类别标题计数
            const categoryTitle = document.querySelector('.category-title');
            if (categoryTitle) {
                // 计算有效的未分类items (排除被跳过的)
                const validUnclassifiedCount = unclassifiedItems.filter(id => !skippedItems.has(id)).length;
                categoryTitle.innerHTML = `${i18n.t('itemsTitle')} <span class="items-count">(${validUnclassifiedCount}/${items.length})</span>`;
            }
            
            // 如果设置对话框可见，立即更新其中的计数
            updateSettingsItemCount();
        }

        // 添加一个函数来在设置对话框可见时实时更新计数
        function updateSettingsItemCount() {
            // 检查设置对话框是否可见
            const settingModal = document.getElementById('setting-modal');
            if (settingModal && settingModal.style.display === 'block') {
                // 如果设置对话框可见，立即更新计数
                forceUpdateItemsCount();
            }
        }

        // 处理图片上传
        function handleFileUpload(files) {
            console.log('=== handleFileUpload开始执行 ===');
            console.log('文件数量：', files ? files.length : 0);
            
            if (!files || files.length === 0) {
                console.log('没有文件，函数退出');
                return;
            }
            
            // 重要：立即将FileList对象转换为数组，避免异步回调时已失效
            const filesArray = Array.from(files);
            
            // 输出文件信息
            filesArray.forEach((file, index) => {
                console.log(`文件${index+1}：${file.name}，类型：${file.type}，大小：${Math.round(file.size/1024)}KB`);
            });
            
            // 文件大小限制设置 - 警告阈值和最大阈值
            const WARNING_SIZE = 5 * 1024 * 1024; // 5MB 显示警告
            const MAX_SIZE = 20 * 1024 * 1024;    // 20MB 拒绝上传
            
            // 检查存储空间
            console.log('调用dbManager.checkStorage()...');
            dbManager.checkStorage().then(storageInfo => {
                console.log('dbManager.checkStorage()成功返回：', storageInfo);
                
                if (storageInfo.usedPercentage > 90) {
                    if (!confirm('存储空间使用率已超过90%，继续上传可能导致数据丢失。是否继续？')) {
                        return;
                    }
                }
                
                // 处理每个文件
                let uploadCount = 0;
                const totalFiles = filesArray.length;
                console.log(`开始处理${totalFiles}个文件...`);
                
                filesArray.forEach(file => {
                    // 检查是否是图片
                    if (!file.type.startsWith('image/')) {
                        console.warn('跳过非图片文件:', file.name);
                        return;
                    }
                    
                    // 检查文件大小
                    if (file.size > MAX_SIZE) {
                        alert(`文件 "${file.name}" 太大 (${Math.round(file.size/1024/1024*100)/100}MB)。请上传小于20MB的文件。`);
                        return;
                    }
                    
                    // 如果文件较大，显示警告但允许上传
                    if (file.size > WARNING_SIZE) {
                        console.warn(`文件 "${file.name}" 较大 (${Math.round(file.size/1024/1024*100)/100}MB)，将自动压缩。`);
                    }
                    
                    console.log(`准备读取文件: ${file.name}`);
                    // 创建文件读取器
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        console.log(`文件读取成功: ${file.name}, 数据长度: ${e.target.result.length}`);
                        // 压缩图片
                        console.log(`开始压缩文件: ${file.name}`);
                        compressImage(e.target.result, file.name, function(compressedImageUrl) {
                            console.log(`文件压缩完成: ${file.name}, 压缩后数据长度: ${compressedImageUrl.length}`);
                            try {
                                // 创建新的item对象
                                const newItem = {
                                    id: Date.now() + Math.floor(Math.random() * 10000), // 使用时间戳+随机数生成唯一ID
                                    title: file.name.split('.')[0], // 使用文件名作为标题
                                    img: compressedImageUrl // 使用压缩后的Data URL
                                };
                                
                                console.log(`创建新项目: ID=${newItem.id}, 标题="${newItem.title}"`);
                                
                                // 添加到items和localItems
                                items.push(newItem);
                                localItems.push(newItem);
                                
                                // 更新未分类items
                                unclassifiedItems.push(newItem.id);
                                
                                // 更新图片缓存
                                imageCache[newItem.id] = newItem.img;
                                
                                // 更新上传计数
                                uploadCount++;
                                console.log(`成功上传 ${uploadCount}/${totalFiles} 个文件`);
                                
                                // 如果所有文件都处理完毕，保存并更新UI
                                if (uploadCount === totalFiles) {
                                    console.log(`所有${totalFiles}个文件处理完成，开始保存到IndexedDB...`);
                                    // 保存到IndexedDB
                                    saveItemsToLocalStorage();
                                    
                                    // 更新计数和UI
                                    console.log(`更新计数和UI...`);
                                    updateItemsCount();
                                    forceUpdateItemsCount();
                                    rerenderAll();
                                    
                                    console.log(`所有${totalFiles}个文件上传完成! UI已更新。`);
                                }
                            } catch (e) {
                                console.error('添加图片时出错:', e);
                                alert('添加图片失败: ' + e.message);
                            }
                        });
                    };
                    
                    reader.onerror = function(error) {
                        console.error(`读取文件失败: "${file.name}"`, error);
                        alert(`无法读取文件 "${file.name}"，请检查文件是否损坏或格式是否支持。`);
                    };
                    
                    // 以Data URL形式读取文件
                    console.log(`开始读取文件为DataURL: ${file.name}`);
                    reader.readAsDataURL(file);
                });
            }).catch(error => {
                console.error('检查存储空间失败:', error);
                // 继续上传，但显示警告
                alert('无法检查存储空间，上传大量图片可能导致数据丢失。');
                
                // 继续处理上传...
                // 直接使用保存的文件数组
                console.log('由于无法检查存储空间，将直接处理文件上传...');
                
                // 处理每个文件
                let uploadCount = 0;
                const totalFiles = filesArray.length;
                
                filesArray.forEach(file => {
                    // 检查是否是图片
                    if (!file.type.startsWith('image/')) {
                        console.warn('跳过非图片文件:', file.name);
                        return;
                    }
                    
                    // 检查文件大小
                    if (file.size > MAX_SIZE) {
                        alert(`文件 "${file.name}" 太大 (${Math.round(file.size/1024/1024*100)/100}MB)。请上传小于20MB的文件。`);
                        return;
                    }
                    
                    // 创建文件读取器
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        // 压缩图片
                        compressImage(e.target.result, file.name, function(compressedImageUrl) {
                            try {
                                // 创建新的item对象
                                const newItem = {
                                    id: Date.now() + Math.floor(Math.random() * 10000),
                                    title: file.name.split('.')[0],
                                    img: compressedImageUrl
                                };
                                
                                // 添加到items和localItems
                                items.push(newItem);
                                localItems.push(newItem);
                                unclassifiedItems.push(newItem.id);
                                imageCache[newItem.id] = newItem.img;
                                
                                uploadCount++;
                                console.log(`成功上传 ${uploadCount}/${totalFiles} 个文件`);
                                
                                if (uploadCount === totalFiles) {
                                    saveItemsToLocalStorage();
                                    updateItemsCount();
                                    forceUpdateItemsCount();
                                    rerenderAll();
                                    console.log(`所有${totalFiles}个文件上传完成`);
                                }
                            } catch (e) {
                                console.error('添加图片时出错:', e);
                                alert('添加图片失败: ' + e.message);
                            }
                        });
                    };
                    
                    reader.onerror = function() {
                        console.error(`读取文件失败: "${file.name}"`);
                        alert(`无法读取文件 "${file.name}"，请检查文件是否损坏或格式是否支持。`);
                    };
                    
                    reader.readAsDataURL(file);
                });
            });
        }
        
        // 压缩图片函数 - 返回压缩后的Data URL
        function compressImage(sourceDataUrl, fileName, callback) {
            // 创建图片元素
            const img = new Image();
            img.onload = function() {
                console.log(`压缩图片: "${fileName}", 原始尺寸: ${img.width}x${img.height}`);
                
                // 最大宽度和高度 - 根据图片尺寸智能调整
                let MAX_WIDTH, MAX_HEIGHT;
                
                // 估算原始图片大小
                const originalSize = estimateImageSize(sourceDataUrl);
                console.log(`估计原始图片大小: ${(originalSize/1024/1024).toFixed(2)}MB`);
                
                // 根据大小调整压缩程度
                if (originalSize > 5 * 1024 * 1024) { // 大于5MB
                    MAX_WIDTH = 600;
                    MAX_HEIGHT = 600;
                } else if (originalSize > 2 * 1024 * 1024) { // 大于2MB
                    MAX_WIDTH = 800;
                    MAX_HEIGHT = 800;
                } else { // 小于2MB
                    MAX_WIDTH = 1200;
                    MAX_HEIGHT = 1200;
                }
                
                // 计算新尺寸
                let width = img.width;
                let height = img.height;
                
                // 等比例缩小
                if (width > MAX_WIDTH) {
                    height = Math.round(height * (MAX_WIDTH / width));
                    width = MAX_WIDTH;
                }
                
                if (height > MAX_HEIGHT) {
                    width = Math.round(width * (MAX_HEIGHT / height));
                    height = MAX_HEIGHT;
                }
                
                console.log(`调整后尺寸: ${width}x${height}`);
                
                // 创建Canvas元素
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                
                // 绘制图片
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                // 确定压缩质量和输出格式
                let outputType = 'image/jpeg';
                
                // 检查是否有透明度或是PNG格式
                const isPNG = fileName.toLowerCase().endsWith('.png');
                const hasTransparency = checkImageTransparency(ctx, width, height);
                
                if (isPNG || hasTransparency) {
                    outputType = 'image/png';
                }
                
                // 逐步压缩直到满足大小要求
                compressWithQuality(canvas, outputType, 0.9, 1024 * 1024, function(result) {
                    console.log(`压缩完成: ${fileName}, 最终大小: ${(estimateImageSize(result)/1024/1024).toFixed(2)}MB`);
                    callback(result);
                });
            };
            
            // 处理加载错误
            img.onerror = function() {
                console.error(`图片加载失败: "${fileName}"`);
                callback(sourceDataUrl); // 失败时返回原始数据
            };
            
            // 加载图片
            img.src = sourceDataUrl;
        }
        
        // 估算图片大小 (base64字符串)
        function estimateImageSize(dataUrl) {
            // 去掉前缀 (data:image/jpeg;base64,)
            const base64 = dataUrl.split(',')[1];
            if (!base64) return 0;
            
            // base64编码比实际数据大约增加33%的大小
            return Math.ceil(base64.length * 0.75);
        }
        
        // 检查图片是否有透明通道
        function checkImageTransparency(ctx, width, height) {
            // 采样检查透明度 (为了效率，只检查几个点)
            const checkPoints = [
                {x: 0, y: 0},                       // 左上
                {x: width-1, y: 0},                 // 右上
                {x: 0, y: height-1},                // 左下
                {x: width-1, y: height-1},          // 右下
                {x: Math.floor(width/2), y: Math.floor(height/2)} // 中心
            ];
            
            for (const point of checkPoints) {
                const pixelData = ctx.getImageData(point.x, point.y, 1, 1).data;
                if (pixelData[3] < 255) { // 有透明度
                    return true;
                }
            }
            
            return false;
        }
        
        // 逐步压缩，直到满足大小要求
        function compressWithQuality(canvas, outputType, initialQuality, maxSize, callback) {
            let quality = initialQuality;
            let result = canvas.toDataURL(outputType, quality);
            let size = estimateImageSize(result);
            let attempts = 1;
            
            console.log(`压缩开始: 质量=${quality}, 大小=${(size/1024/1024).toFixed(2)}MB`);
            
            // 如果已经满足要求，直接返回
            if (size <= maxSize) {
                console.log(`无需进一步压缩，已满足大小要求`);
                callback(result);
                return;
            }
            
            // 递归压缩，直到小于最大尺寸
            function compress() {
                // 计算新的质量值 - 根据当前大小与目标大小比例调整
                quality = Math.max(0.1, quality * (maxSize / size) * 0.9);
                result = canvas.toDataURL(outputType, quality);
                size = estimateImageSize(result);
                attempts++;
                
                console.log(`压缩第${attempts}次: 质量=${quality.toFixed(2)}, 大小=${(size/1024/1024).toFixed(2)}MB`);
                
                if (size <= maxSize || attempts >= 5 || quality <= 0.2) {
                    // 如果满足大小要求、达到最大尝试次数或质量已经很低，返回结果
                    callback(result);
                } else {
                    // 继续压缩
                    compress();
                }
            }
            
            compress();
        }

        // 生成唯一ID
        function generateUniqueId() {
            // 找到当前最大ID
            const maxId = items.length > 0 ? Math.max(...items.map(item => {
                // 确保所有ID都被解析为数字
                return typeof item.id === 'number' ? item.id : parseInt(item.id, 10) || 0;
            })) : 0;
            return maxId + 1;
        }

        // 删除item
        function deleteItem(id) {
            console.log(`开始删除项目: ID=${id}`);
            
            // 确保ID比较使用字符串比较以防止类型不匹配
            const stringId = String(id);
            
            // 从items中移除
            const index = items.findIndex(item => String(item.id) === stringId);
            if (index !== -1) {
                console.log(`从items中删除项目: 索引=${index}, ID=${items[index].id}, 标题="${items[index].title}"`);
                items.splice(index, 1);
                
                // 从localItems中移除
                const localIndex = localItems.findIndex(item => String(item.id) === stringId);
                if (localIndex !== -1) {
                    console.log(`从localItems中删除项目: 索引=${localIndex}`);
                    localItems.splice(localIndex, 1);
                }
                
                // 从unclassifiedItems中移除，确保ID比较一致
                const unclassifiedIndex = unclassifiedItems.findIndex(itemId => String(itemId) === stringId);
                if (unclassifiedIndex !== -1) {
                    console.log(`从unclassifiedItems中删除项目: 索引=${unclassifiedIndex}`);
                    unclassifiedItems.splice(unclassifiedIndex, 1);
                } else {
                    console.log(`项目不在unclassifiedItems中`);
                }
                
                // 从classifiedItems中移除，确保ID比较一致
                const classifiedIndex = classifiedItems.findIndex(ci => String(ci.id) === stringId);
                if (classifiedIndex !== -1) {
                    console.log(`从classifiedItems中删除项目: 索引=${classifiedIndex}, 级别=${classifiedItems[classifiedIndex].tier}`);
                    classifiedItems.splice(classifiedIndex, 1);
                } else {
                    console.log(`项目不在classifiedItems中`);
                }
                
                // 重置跳过状态
                if (skippedItems.has(id)) {
                    console.log(`移除跳过状态`);
                    skippedItems.delete(id);
                }
                
                // 立即保存状态到localStorage - 简化保存逻辑
                try {
                    localStorage.setItem('tiermaker-items', JSON.stringify(localItems));
                    localStorage.setItem('tiermaker-classified-items', JSON.stringify(classifiedItems));
                    localStorage.setItem('tiermaker-unclassified-items', JSON.stringify(unclassifiedItems));
                    localStorage.setItem('tiermaker-skipped-items', JSON.stringify(Array.from(skippedItems)));
                    console.log('项目状态已成功保存到localStorage');
                } catch (e) {
                    console.error('保存到localStorage失败:', e);
                }
                
                // 从IndexedDB中删除项目 - 异步进行不阻塞界面
                setTimeout(() => {
                    dbManager.deleteItem(id).then(() => {
                        console.log(`成功从IndexedDB中删除项目: ID=${id}`);
                    }).catch(error => {
                        console.error(`从IndexedDB删除项目失败: ID=${id}`, error);
                    });
                    
                    // 保存设置到IndexedDB
                    dbManager.saveSettings({
                        'classified-items': classifiedItems,
                        'unclassified-items': unclassifiedItems,
                        'skipped-items': Array.from(skippedItems)
                    }).catch(error => {
                        console.error('保存设置到IndexedDB失败:', error);
                    });
                }, 0);
                
                // 更新计数
                updateItemsCount();
                
                // 移除图片缓存
                if (imageCache[id]) {
                    delete imageCache[id];
                }
                
                // 重新渲染
                rerenderAll();
                
                console.log(`项目删除成功: ID=${id}`);
                return true;
            } else {
                console.warn(`要删除的项目不存在: ID=${id}`);
                return false;
            }
        }

        // 保存设置
        function saveCurrentSettings() {
            // 保存图片比例设置
            localStorage.setItem('tiermaker-image-ratio', currentImageRatio);
            
            // 保存标题
            const mainTitle = document.getElementById('main-title').textContent;
            localStorage.setItem('tiermaker-title', mainTitle);
            
            // 保存创建者名称
            const creatorNameInput = document.getElementById('creator-name-input');
            if (creatorNameInput) {
                localStorage.setItem('tiermaker-creator-name', creatorNameInput.value);
            }
            
            // 保存访问权限设置
            const accessSelect = document.getElementById('access-select');
            if (accessSelect) {
                localStorage.setItem('tiermaker-access', accessSelect.value);
            }
            
            // 保存tier设置 - 使用getTiers()方法代替getSettings()
            const tiersData = {
                tiers: tierManager.getTiers(),
                tierNames: {}, // 存储自定义名称
                tierLimits: {} // 存储数量限制
            };
            
            // 存储每个tier的自定义名称和限制
            tierManager.getTiers().forEach(tier => {
                // 保存自定义名称
                const name = tierManager.getTierName(tier);
                if (name && name !== tier) {
                    tiersData.tierNames[tier] = name;
                }
                
                // 保存限制
                const limit = tierManager.getTierLimit(tier);
                if (limit !== null) {
                    tiersData.tierLimits[tier] = limit;
                }
            });
            
            localStorage.setItem('tiermaker-tiers', JSON.stringify(tiersData));
        }

        // 应用图片比例设置
        function applyImageRatio(ratio) {
            currentImageRatio = ratio;
            
            // 为所有卡片添加overflow:hidden
            document.querySelectorAll('.item-card').forEach(card => {
                card.style.overflow = 'hidden';
                
                // 更新tier中卡片尺寸
                if (card.closest('.tier-content')) {
                    const dimensions = getCardDimensionsByRatio(ratio);
                    card.style.width = dimensions.width;
                    card.style.height = dimensions.height;
                }
            });
            
            // 更新所有已存在的项目卡片图片样式
            document.querySelectorAll('.item-card img').forEach(img => {
                img.classList.remove('ratio-portrait', 'ratio-square', 'ratio-landscape', 'ratio-round');
                img.classList.add(`ratio-${ratio}`);
                
                // 重置样式以防止继承旧的值
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                
                if (ratio === 'round') {
                    img.style.borderRadius = '50%';
                } else {
                    img.style.borderRadius = '';
                }
            });
            
            // 更新预览图片
            const previewImg = document.querySelector('.item-preview .item-image');
            if (previewImg) {
                previewImg.classList.remove('ratio-portrait', 'ratio-square', 'ratio-landscape', 'ratio-round');
                previewImg.classList.add(`ratio-${ratio}`);
                
                const dimensions = getPreviewDimensionsByRatio(ratio);
                previewImg.style.width = dimensions.width;
                previewImg.style.height = dimensions.height;
                previewImg.style.objectFit = 'cover';
                
                if (ratio === 'round') {
                    previewImg.style.borderRadius = '50%';
                } else {
                    previewImg.style.borderRadius = '';
                }
            }
            
            // 保存设置
            saveCurrentSettings();
            
            // 重新渲染所有项目以确保正确应用样式
            rerenderAll();
        }

        // 初始化图片比例设置
        function initImageRatio() {
            // 从本地存储获取设置
            const savedRatio = localStorage.getItem('tiermaker-image-ratio');
            if (savedRatio) {
                currentImageRatio = savedRatio;
                // 更新选择框
                const ratioSelect = document.getElementById('image-ratio-select');
                if (ratioSelect) {
                    ratioSelect.value = savedRatio;
                }
            }
            
            // 应用设置
            applyImageRatio(currentImageRatio);
        }

        // 添加CSS样式定义不同的图片比例
        function addImageRatioStyles() {
            const style = document.createElement('style');
            style.textContent = `
                .ratio-portrait {
                    aspect-ratio: 2/3 !important;
                }
                .ratio-square {
                    aspect-ratio: 1/1 !important;
                }
                .ratio-landscape {
                    aspect-ratio: 3/2 !important;
                }
                .ratio-round {
                    aspect-ratio: 1/1 !important;
                }
                .ratio-round img {
                    border-radius: 50% !important;
                    object-fit: cover;
                }
            `;
            document.head.appendChild(style);
        }

        // 设置右键菜单
        function setupContextMenu() {
            const contextMenu = document.getElementById('context-menu');
            
            // 阻止默认右键菜单 - items-grid
            document.querySelector('.items-grid').addEventListener('contextmenu', e => {
                e.preventDefault();
                
                // 获取点击的item-card
                const card = e.target.closest('.item-card');
                
                // 显示菜单
                contextMenu.style.display = 'block';
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;
                
                // 记录当前操作的item ID
                if (card) {
                    contextMenu.setAttribute('data-item-id', card.getAttribute('data-id'));
                } else {
                    contextMenu.removeAttribute('data-item-id');
                }
                
                // 根据是否在item-card上点击来控制菜单项的显示
                const deleteOption = contextMenu.querySelector('[data-action="delete"]');
                const editTitleOption = contextMenu.querySelector('[data-action="edit-title"]');
                if (card) {
                    deleteOption.style.display = 'block';
                    editTitleOption.style.display = 'block';
                } else {
                    deleteOption.style.display = 'none';
                    editTitleOption.style.display = 'none';
                }
            });
            
            // 阻止默认右键菜单 - tiers-list
            document.querySelector('.tier-list-container').addEventListener('contextmenu', e => {
                e.preventDefault();
                
                // 获取点击的item-card
                const card = e.target.closest('.item-card');
                
                // 显示菜单
                contextMenu.style.display = 'block';
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;
                
                // 记录当前操作的item ID
                if (card) {
                    contextMenu.setAttribute('data-item-id', card.getAttribute('data-id'));
                    
                    // 启用删除和编辑标题选项
                    const deleteOption = contextMenu.querySelector('[data-action="delete"]');
                    const editTitleOption = contextMenu.querySelector('[data-action="edit-title"]');
                    deleteOption.style.display = 'block';
                    editTitleOption.style.display = 'block';
                } else {
                    contextMenu.removeAttribute('data-item-id');
                    
                    // 禁用删除和编辑标题选项
                    const deleteOption = contextMenu.querySelector('[data-action="delete"]');
                    const editTitleOption = contextMenu.querySelector('[data-action="edit-title"]');
                    deleteOption.style.display = 'none';
                    editTitleOption.style.display = 'none';
                }
            });
            
        }

        // 初始化Items Management功能
        function initItemsManagement() {
            // 添加图片比例样式
            addImageRatioStyles();
            
            // 初始化图片比例设置
            initImageRatio();
            
            // 初始化items
            initItems();
            
            // 设置右键菜单
            setupContextMenu();
            
            // 绑定Choose Files按钮点击事件
            document.getElementById('choose-files-btn').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });
            
            // 绑定Type Texts按钮点击事件
            document.getElementById('type-texts-btn').addEventListener('click', () => {
                document.getElementById('modal-overlay').style.display = 'block';
                document.getElementById('text-input-modal').style.display = 'block';
                document.getElementById('text-input-area').value = ''; // 清空文本区域
            });
            
            // Buy Me a Coffee按钮点击事件
            document.getElementById('buy-coffee-btn').addEventListener('click', () => {
                window.open('https://www.buymeacoffee.com/yourname', '_blank');
            });
            
            // Contact按钮点击事件
            document.getElementById('contact-btn').addEventListener('click', () => {
                window.open('https://c-hri-sw-u.github.io/', '_blank');
            });
            
            // 绑定取消文本输入按钮点击事件
            document.getElementById('cancel-text-btn').addEventListener('click', () => {
                // 更新items计数，确保在下次打开时显示正确
                forceUpdateItemsCount();
                
                // 关闭模态窗口
                document.getElementById('modal-overlay').style.display = 'none';
                document.getElementById('text-input-modal').style.display = 'none';
            });
            
            // 绑定生成卡片按钮点击事件
            document.getElementById('generate-cards-btn').addEventListener('click', () => {
                const textInput = document.getElementById('text-input-area').value;
                createItemsFromText(textInput);
                document.getElementById('modal-overlay').style.display = 'none';
                document.getElementById('text-input-modal').style.display = 'none';
            });
            
            // 绑定清除所有项目按钮点击事件
            document.getElementById('clear-items-btn').addEventListener('click', () => {
                const clearBtn = document.getElementById('clear-items-btn');
                
                // 检查按钮是否处于确认状态
                if (clearBtn.getAttribute('data-confirm') === 'true') {
                    // 已经在确认状态，执行清除操作
                    clearAllItems();
                    
                    // 操作完成后恢复按钮状态
                    clearBtn.textContent = i18n.t('clear');
                    clearBtn.style.background = '#333';
                    clearBtn.removeAttribute('data-confirm');
                } else {
                    // 进入确认状态
                    clearBtn.textContent = i18n.t('confirm');
                    clearBtn.style.background = '#ff0000';
                    clearBtn.setAttribute('data-confirm', 'true');
                    
                    // 点击其他区域取消确认状态
                    const cancelConfirm = (e) => {
                        if (e.target !== clearBtn) {
                            clearBtn.textContent = i18n.t('clear');
                            clearBtn.style.background = '#333';
                            clearBtn.removeAttribute('data-confirm');
                            document.removeEventListener('click', cancelConfirm);
                        }
                    };
                    
                    // 延迟一下添加点击事件，避免立即触发
                    setTimeout(() => {
                        document.addEventListener('click', cancelConfirm);
                    }, 10);
                }
            });
            
            // 绑定文件输入变化事件
            document.getElementById('file-input').addEventListener('change', e => {
                handleFileUpload(e.target.files);
                // 重置文件输入，以便可以再次选择相同的文件
                e.target.value = '';
            });
            
            // 绑定图片比例选择变化事件
            document.getElementById('image-ratio-select').addEventListener('change', e => {
                applyImageRatio(e.target.value);
            });
        }

        // 初始化图片缓存
        function initImageCache() {
            imageCache = {}; // 清空缓存
            
            // 为所有项目创建缓存条目
            items.forEach(item => {
                if (item && item.id !== undefined && item.img) {
                    // 确保ID一致性，转为字符串
                    const itemId = String(item.id);
                    imageCache[itemId] = item.img;
                }
            });
            
            console.log(`图片缓存已初始化，共 ${Object.keys(imageCache).length} 个项目`);
        }

        // 在初始化函数中调用
        function init() {
            // 初始化IndexedDB
            dbManager.initDB().then(() => {
                console.log('IndexedDB初始化成功');
                
                // 检查存储空间
                return dbManager.checkStorage();
            }).then(storageInfo => {
                if (storageInfo.quota > 0) {
                    console.log(`存储空间状态: ${(storageInfo.usage/1024/1024).toFixed(2)}MB / ${(storageInfo.quota/1024/1024).toFixed(2)}MB (${storageInfo.usedPercentage.toFixed(2)}%)`);
                    
                    // 如果存储空间使用率超过90%，显示警告
                    if (storageInfo.usedPercentage > 90) {
                        console.warn('存储空间使用率超过90%，可能会影响新图片的保存');
                    }
                }
            }).catch(error => {
                console.error('IndexedDB初始化失败:', error);
            });
            
            // 初始化语言系统
            i18n.init();
            
            // 恢复保存的标题
            const savedTitle = localStorage.getItem('tiermaker-custom-title');
            const mainTitle = document.getElementById('main-title');
            if (savedTitle && mainTitle) {
                mainTitle.textContent = savedTitle;
                console.log('Restored saved title:', savedTitle);
            }
            
            // 恢复保存的创建者名称
            const savedCreatorName = localStorage.getItem('tiermaker-creator-name');
            const creatorNameInput = document.getElementById('creator-name-input');
            if (savedCreatorName && creatorNameInput) {
                creatorNameInput.value = savedCreatorName;
                console.log('Restored saved creator name:', savedCreatorName);
            }
            
            // 初始化Items Management功能
            initItemsManagement();
            
            // 确保加载跳过状态
            loadSkippedItems();
            console.log('初始化时加载跳过状态:', Array.from(skippedItems));
            
            // 渲染界面
            rerenderAll();
            
            // 确保items计数正确
            updateItemsCount();
            
            // 设置标题编辑事件
            setupTitleEditEvents();
            
            // 初始化图片缓存
            initImageCache();
            
            // 修复设置标题
            setTimeout(fixSettingsLabels, 500);
            
            // 强制显示设置元素
            setTimeout(forceDisplaySettingsElements, 1000);
            // 强制更新item计数
            setTimeout(forceUpdateItemsCount, 1000);
            
            // 设置重置按钮
            setupResetButton();
            console.log('已设置Reset按钮');
        }

        // 调用初始化
        init();

        // 更新tiers-list中的图像
        document.querySelectorAll('.tier-content .item-card').forEach(card => {
            // 重新设置卡片尺寸比例
            if (currentImageRatio === 'round' || currentImageRatio === 'square') {
                card.style.width = '60px';
                card.style.height = '60px';
            } else if (currentImageRatio === 'landscape') {
                card.style.width = '75px';
                card.style.height = '50px'; 
            } else { // portrait
                card.style.width = '40px';
                card.style.height = '60px';
            }
            
            // 更新图片样式
            const img = card.querySelector('img');
            if (img) {
                img.classList.remove('ratio-portrait', 'ratio-square', 'ratio-landscape', 'ratio-round');
                img.classList.add(`ratio-${currentImageRatio}`);
                
                if (currentImageRatio === 'round') {
                    img.style.borderRadius = '50%';
                } else {
                    img.style.borderRadius = '';
                }
                img.style.objectFit = 'cover';
                img.style.width = '100%';
                img.style.height = '100%';
            }
        });

        // 重置和刷新所有图片
        function resetAllImages() {
            // 先缓存所有项目的图片URL以防止错误引用
            const localImageCache = {};
            items.forEach(item => {
                if (item && item.id) {
                    localImageCache[item.id] = item.img;
                }
            });
            
            // 删除所有现有图片元素
            document.querySelectorAll('.item-card').forEach(card => {
                // 获取卡片ID
                const itemId = Number(card.getAttribute('data-id'));
                if (!itemId || !localImageCache[itemId]) return;
                
                // 清空卡片内容
                card.innerHTML = '';
                
                // 设置加载背景
                card.style.backgroundColor = '#333';
                
                // 创建图片
                const img = createImageElement(localImageCache[itemId], itemId, {
                    onLoad: function() {
                        card.style.backgroundColor = '';
                    }
                });
                
                // 附加图片到卡片
                card.appendChild(img);
                
                // 检查是否在items-grid中并且是被跳过的项目
                if (card.parentNode && card.parentNode.className === 'items-grid') {
                    // 如果是被跳过的项目，添加skipped类和标签
                    if (skippedItems.has(itemId)) {
                        card.classList.add('skipped');
                        card.appendChild(createSkippedBadge());
                    } else {
                        // 如果不是被跳过的项目，确保移除skipped类
                        card.classList.remove('skipped');
                    }
                }
            });
        }

        // ========== 通用图片处理函数 ==========

        // 创建图片元素并应用样式
        function createImageElement(imageUrl, itemId, options = {}) {
            const img = new Image();
            img.className = options.className || 'item-image';
            img.alt = options.alt || 'Item ' + itemId;
            img.draggable = options.draggable === true; // 默认不可拖动
            
            // 应用基本样式
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.objectPosition = 'center';
            
            // 根据图片比例应用特定样式
            if (currentImageRatio === 'round') {
                img.style.borderRadius = '50%';
            } else {
                img.style.borderRadius = '';
            }
            
            // 如果提供了回调函数，添加事件监听器
            if (typeof options.onLoad === 'function') {
                img.onload = options.onLoad;
            }
            
            if (typeof options.onError === 'function') {
                img.onerror = options.onError;
            } else {
                // 默认错误处理
                img.onerror = function() {
                    console.error(`图片加载失败: ID=${itemId}`);
                    img.src = 'https://dummyimage.com/60x60/ff0000/ffffff&text=Error';
                };
            }
            
            // 设置图片源
            img.src = imageUrl;
            
            return img;
        }

        // 清除容器中的所有图片
        function clearImages(container) {
            if (typeof container === 'string') {
                container = document.querySelector(container);
            }
            
            if (container) {
                const images = container.querySelectorAll('.item-image');
                images.forEach(img => img.remove());
            }
        }

        // 根据比例获取卡片尺寸
        function getCardDimensionsByRatio(ratio) {
            if (ratio === 'round' || ratio === 'square') {
                return { width: '60px', height: '60px' };
            } else if (ratio === 'landscape') {
                return { width: '75px', height: '50px' };
            } else { // portrait
                return { width: '40px', height: '60px' };
            }
        }

        // 根据比例获取预览图片尺寸
        function getPreviewDimensionsByRatio(ratio) {
            if (ratio === 'round' || ratio === 'square') {
                return { width: '220px', height: '220px' };
            } else if (ratio === 'landscape') {
                return { width: '220px', height: '147px' };
            } else { // portrait
                return { width: '150px', height: '220px' };
            }
        }

        // 创建跳过标签
        function createSkippedBadge() {
            const badge = document.createElement('div');
            badge.className = 'skipped-badge';
            badge.textContent = 'Skipped';
            badge.style.position = 'absolute';
            badge.style.top = '0';
            badge.style.left = '0';
            badge.style.right = '0';
            badge.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
            badge.style.color = 'white';
            badge.style.textAlign = 'center';
            badge.style.padding = '2px';
            badge.style.fontSize = '12px';
            badge.style.fontWeight = 'bold';
            badge.style.zIndex = '10';
            return badge;
        }

        // ========== 通用拖放处理函数 ==========

        // 处理所有类型的拖放操作
        function handleDragDrop(data) {
            const { id, sourceType, targetType, sourceTier, targetTier, dropIndex } = data;
            
            // 先查找完整的item数据
            const originalItem = items.find(item => String(item.id) === String(id));
            if (!originalItem) {
                console.error(`拖放错误: 找不到ID为${id}的项目`);
                return;
            }
            
            // 根据不同的拖放类型执行不同的操作
            if (sourceType === 'grid' && targetType === 'tier') {
                // 从grid到tier的拖放
                
                // 检查tier限制
                const tierItems = classifiedItems.filter(ci => ci.tier === targetTier);
                const tierLimit = tierManager.getTierLimit(targetTier);
                if (tierLimit !== null && tierItems.length >= tierLimit) {
                    // 达到限制，高亮显示限制
                    highlightTierLimitReached(targetTier);
                    return;
                }
                
                // 计算order值
                const order = getOrderForPosition(targetTier, dropIndex);
                
                // 添加到classifiedItems
                classifiedItems.push({ id: originalItem.id, tier: targetTier, order });
                
                // 从unclassifiedItems中移除
                unclassifiedItems = unclassifiedItems.filter(i => String(i) !== String(id));
                
                // 重置跳过状态
                skippedItems.delete(id);
                saveSkippedItems(); // 保存跳过状态更新
                
                // 重新索引该tier中的items
                reindexTierItems(targetTier);
                
            } else if (sourceType === 'tier' && targetType === 'tier' && sourceTier === targetTier) {
                // 同一tier内的排序
                
                // 获取该tier中的所有items
                const tierItems = classifiedItems
                    .filter(ci => ci.tier === targetTier)
                    .sort((a, b) => a.order - b.order);
                
                // 找到被拖拽的item
                const draggedItem = tierItems.find(ti => String(ti.id) === String(id));
                if (!draggedItem) return;
                
                // 当前位置
                const oldIndex = tierItems.indexOf(draggedItem);
                
                // 如果位置没变，不做任何操作
                if (oldIndex === dropIndex) return;
                
                // 移动item
                tierItems.splice(oldIndex, 1);
                tierItems.splice(dropIndex, 0, draggedItem);
                
                // 重新设置order
                tierItems.forEach((item, index) => {
                    item.order = index + 1;
                });
                
            } else if (sourceType === 'tier' && targetType === 'tier' && sourceTier !== targetTier) {
                // 从一个tier到另一个tier的拖放
                
                // 检查目标tier限制
                const targetTierItems = classifiedItems.filter(ci => ci.tier === targetTier);
                const targetTierLimit = tierManager.getTierLimit(targetTier);
                if (targetTierLimit !== null && targetTierItems.length >= targetTierLimit) {
                    // 达到限制，高亮显示限制
                    highlightTierLimitReached(targetTier);
                    return;
                }
                
                // 找到被拖拽的item
                const item = classifiedItems.find(ci => String(ci.id) === String(id));
                if (!item) return;
                
                // 更新tier
                item.tier = targetTier;
                
                // 计算新的order
                item.order = getOrderForPosition(targetTier, dropIndex);
                
                // 重新索引两个tier的items
                reindexTierItems(sourceTier);
                reindexTierItems(targetTier);
            }
            
            // 保存到localStorage确保持久化
            saveItemsToLocalStorage();
            
            // 清除预览图片
            clearImages('.item-preview');
            
            // 重新渲染
            rerenderAll();
        }


        // 设置标题编辑事件
        function setupTitleEditEvents() {
            // 允许编辑主标题
            const mainTitle = document.getElementById('main-title');
            if (mainTitle) {
                // 如果已经是可编辑的，不要再设置
                if (!mainTitle.hasAttribute('contenteditable')) {
                    mainTitle.setAttribute('contenteditable', 'true');
                    mainTitle.style.cursor = 'pointer';
                    
                    // 添加输入事件监听器，保存更改到localStorage
                    mainTitle.addEventListener('input', () => {
                        localStorage.setItem('tiermaker-custom-title', mainTitle.textContent);
                    });
                    
                    // 添加失去焦点事件监听器
                    mainTitle.addEventListener('blur', () => {
                        if (mainTitle.textContent.trim() === '') {
                            mainTitle.textContent = i18n.t('mainTitle');
                        }
                    });
                }
            }
            
            // 允许双击编辑预览中的item标题
            setupItemTitleEditEvent();
        }

        // 设置item标题双击编辑事件
        function setupItemTitleEditEvent() {
            const itemTitle = document.querySelector('.item-title');
            if (!itemTitle) return;
            
            // 添加双击事件监听器
            itemTitle.addEventListener('dblclick', function() {
                // 获取当前预览的item
                const { previewId } = getPreviewInfo();
                if (!previewId) return;
                
                // 找到对应的item对象
                const item = items.find(i => i.id === previewId);
                if (!item) return;
                
                // 设置为可编辑状态
                this.setAttribute('contenteditable', 'true');
                this.style.cursor = 'text';
                this.style.border = '1px dashed #fff';
                this.style.padding = '4px';
                this.focus();
                
                // 选中所有文本
                window.getSelection().selectAllChildren(this);
                
                // 阻止拖放期间的编辑
                if (isClassifying) {
                    this.setAttribute('contenteditable', 'false');
                    return;
                }
                
                // 保存原始标题，用于取消编辑时恢复
                this.setAttribute('data-original-title', this.textContent);
                
                // 处理编辑完成
                const completeEdit = () => {
                    // 移除编辑状态
                    this.removeAttribute('contenteditable');
                    this.style.cursor = '';
                    this.style.border = '';
                    this.style.padding = '';
                    
                    // 如果标题为空，恢复原始标题
                    if (this.textContent.trim() === '') {
                        this.textContent = this.getAttribute('data-original-title') || item.title;
                        return;
                    }
                    
                    // 如果标题未变化，无需更新
                    if (this.textContent === item.title) return;
                    
                    // 更新item标题
                    const newTitle = this.textContent.trim();
                    item.title = newTitle;
                    
                    // 更新本地items
                    const localItem = localItems.find(i => i.id === previewId);
                    if (localItem) {
                        localItem.title = newTitle;
                    }
                    
                    // 如果是文字卡片，更新图片
                    if (item.isTextGenerated) {
                        updateTextCardImage(item);
                    }
                    
                    // 保存到localStorage
                    saveItemsToLocalStorage();
                    
                    // 重新渲染所有UI以反映更改
                    rerenderAll();
                    
                    console.log(`Item标题已更新: ID=${previewId}, 新标题="${newTitle}"`);
                };
                
                // 添加事件监听器
                const onBlur = () => {
                    completeEdit();
                    this.removeEventListener('blur', onBlur);
                };
                
                const onKeyDown = (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        completeEdit();
                        this.removeEventListener('keydown', onKeyDown);
                        this.blur();
                    } else if (e.key === 'Escape') {
                        // 取消编辑，恢复原始标题
                        this.textContent = this.getAttribute('data-original-title') || item.title;
                        this.removeAttribute('contenteditable');
                        this.style.cursor = '';
                        this.style.border = '';
                        this.style.padding = '';
                        this.removeEventListener('keydown', onKeyDown);
                        this.blur();
                    }
                };
                
                this.addEventListener('blur', onBlur);
                this.addEventListener('keydown', onKeyDown);
            });
        }

        // 为文字卡片更新图片
        // 修复标题显示问题
        function fixSettingsLabels() {
            // 确保所有设置的标题正确显示
            const settingModal = document.getElementById('setting-modal');
            if (settingModal) {
                const headings = settingModal.querySelectorAll('h3');
                if (headings.length >= 3) {
                    headings[0].textContent = i18n.t('basicSettings');
                    headings[1].textContent = i18n.t('tierManagement');
                    headings[2].textContent = i18n.t('itemsManagement');
                }
                
                // 确保所有标签也正确显示
                const labels = settingModal.querySelectorAll('label');
                labels.forEach(label => {
                    const labelParent = label.parentElement;
                    const nextElement = labelParent.querySelector('select, input');
                    
                    if (nextElement && nextElement.id === 'access-select') {
                        label.textContent = i18n.t('access');
                    } else if (nextElement && nextElement.id === 'title-input') {
                        label.textContent = i18n.t('title');
                    } else if (nextElement && nextElement.id === 'image-ratio-select') {
                        label.textContent = i18n.t('imageRatio');
                    } else if (labelParent.querySelector('.file-selection')) {
                        label.textContent = i18n.t('items');
                    }
                });
                
                // 修复item选择计数
                updateItemsCount();
                
                // 修复tier管理表格中的图标显示
                setTimeout(() => {
                    document.querySelectorAll('.tier-handle, .tier-delete-btn').forEach(el => {
                        el.style.display = el.tagName === 'TD' ? 'table-cell' : 'inline-block';
                    });
                }, 100);
            }
        }

        // 强制显示设置面板中的元素
        let settingsElementsForced = false; // 添加标志，防止重复强制显示
        
        function forceDisplaySettingsElements() {
            // 避免短时间内重复调用
            if (settingsElementsForced) {
                return;
            }
            
            console.log('强制显示设置面板元素');
            
            // 强制显示tier-handle和tier-delete-btn
            document.querySelectorAll('.tier-handle').forEach(el => {
                el.classList.add('forced-tier-handle');
                const span = el.querySelector('span');
                if (span) {
                    span.classList.add('forced-tier-handle-span');
                } else {
                    el.innerHTML = '<span class="forced-tier-handle-span">≡</span>';
                }
            });
            
            document.querySelectorAll('.tier-delete-btn').forEach(el => {
                el.classList.add('forced-tier-delete-btn');
                const span = el.querySelector('span');
                if (span) {
                    span.classList.add('forced-tier-delete-span');
                } else {
                    el.innerHTML = '<span class="forced-tier-delete-span">×</span>';
                }
            });
            
            // 强制显示选择信息
            const selectionInfo = document.querySelector('.selection-info');
            if (selectionInfo) {
                selectionInfo.classList.add('forced-selection-info');
            }
            
            // 设置标志，避免短时间内重复调用
            settingsElementsForced = true;
            setTimeout(() => {
                settingsElementsForced = false; // 1秒后重置标志
            }, 1000);
            
            // 重新渲染tier设置
            renderTierSettings();
            
            console.log('已强制显示所有设置元素');
        }

        // 强制执行显示计数的更新，并确保选择信息显示正确
        let itemsCountUpdateForced = false; // 添加标志，防止重复更新
        
        function forceUpdateItemsCount() {
            // 避免短时间内重复调用
            if (itemsCountUpdateForced) {
                return;
            }
            
            // 强制创建和显示选择信息元素
            const selectionInfo = ensureSelectionInfoExists();
            
            const itemsCountEl = document.getElementById('items-count');
            if (itemsCountEl) {
                // 确保items-count元素有正确的文本内容
                itemsCountEl.textContent = items.length.toString();
            }
            
            // 更新显示计数的信息
            if (selectionInfo) {
                // 直接拼接字符串显示项目数量，而不是依赖i18n的参数替换
                const selectedItemsText = i18n.t('selectedItems');
                selectionInfo.innerHTML = `${selectedItemsText} (${items.length})`;
                
                // 确保元素可见
                selectionInfo.style.display = 'inline-block';
                selectionInfo.style.minWidth = '150px';
                selectionInfo.style.marginLeft = '10px';
                selectionInfo.style.color = 'var(--text-color)';
                selectionInfo.style.verticalAlign = 'middle';
                
                // 添加强制显示的类
                selectionInfo.classList.add('forced-selection-info');
            }
            
            // 设置标志，避免短时间内重复调用
            itemsCountUpdateForced = true;
            setTimeout(() => {
                itemsCountUpdateForced = false; // 500ms后重置标志
            }, 500);
        }

        // 在文档加载完成后立即执行
        let domInitialized = false;
        
        document.addEventListener('DOMContentLoaded', function() {
            if (domInitialized) return;
            domInitialized = true;
            
            // 初始化i18n
            i18n.init();
            
            // 设置语言切换事件
            const langOptions = document.querySelectorAll('.language-option');
            langOptions.forEach(option => {
                option.addEventListener('click', () => {
                    const lang = option.getAttribute('data-lang');
                    if (lang) {
                        i18n.setLanguage(lang);
                        // 隐藏下拉菜单
                        document.getElementById('language-dropdown').style.display = 'none';
                        // 重新渲染所有需要翻译的内容
                        rerenderAll();
                    }
                });
            });
            
            // 设置语言按钮点击事件，显示/隐藏下拉菜单
            const langBtn = document.getElementById('language-btn');
            const langDropdown = document.getElementById('language-dropdown');
            if (langBtn && langDropdown) {
                console.log('找到语言按钮和下拉菜单');
                
                // 确保下拉菜单初始隐藏
                langDropdown.style.display = 'none';
                
                // 移除旧事件处理
                langBtn.onclick = null;
                
                // 添加新事件处理
                langBtn.addEventListener('click', function(event) {
                    console.log('语言按钮被点击');
                    event.stopPropagation();
                    event.preventDefault();
                    
                    if (langDropdown.style.display === 'block') {
                        langDropdown.style.display = 'none';
                        console.log('关闭语言下拉菜单');
                    } else {
                        langDropdown.style.display = 'block';
                        console.log('打开语言下拉菜单');
                    }
                }, true);
                
                // 点击其他区域关闭下拉菜单
                document.addEventListener('click', (e) => {
                    if (e.target !== langBtn && !langDropdown.contains(e.target)) {
                        langDropdown.style.display = 'none';
                    }
                });
            }
            
            setTimeout(function() {
                forceDisplaySettingsElements();
                forceUpdateItemsCount();
                console.log('已强制显示所有设置元素');
            }, 500);
        });

        // 在页面加载完成后重新渲染一次所有元素
        let pageLoadInitialized = false;
        
        window.addEventListener('load', function() {
            if (pageLoadInitialized) return;
            pageLoadInitialized = true;
            
            setTimeout(function() {
                forceDisplaySettingsElements();
                forceUpdateItemsCount();
                console.log('页面加载后已强制显示所有设置元素');
            }, 1000);
        });

        // 确保选择信息元素存在
        let selectionInfoCreated = false; // 添加标志，防止重复创建
        
        function ensureSelectionInfoExists() {
            // 如果已经创建过，直接返回
            if (selectionInfoCreated) {
                return document.querySelector('.selection-info');
            }
            
            // 检查.selection-info是否存在
            let selectionInfo = document.querySelector('.selection-info');
            if (!selectionInfo) {
                // 如果不存在，创建一个
                const fileSelection = document.querySelector('.file-selection');
                if (fileSelection) {
                    selectionInfo = document.createElement('span');
                    selectionInfo.className = 'selection-info forced-selection-info';
                    
                    // 直接拼接字符串显示项目数量，与forceUpdateItemsCount保持一致
                    const selectedItemsText = i18n.t('selectedItems');
                    selectionInfo.innerHTML = `${selectedItemsText} (${items.length})`;
                    
                    // 确保元素可见
                    selectionInfo.style.display = 'inline-block';
                    selectionInfo.style.minWidth = '150px';
                    selectionInfo.style.marginLeft = '10px';
                    selectionInfo.style.color = 'var(--text-color)';
                    selectionInfo.style.verticalAlign = 'middle';
                    
                    fileSelection.appendChild(selectionInfo);
                    console.log('创建了.selection-info元素');
                    selectionInfoCreated = true; // 标记为已创建
                }
            } else {
                selectionInfoCreated = true; // 标记为已创建
            }
            return selectionInfo;
        }

        // 在打开设置对话框时专门处理选择信息元素
        document.getElementById('setting-btn').addEventListener('click', () => {
            // 先显示模态窗口
            document.getElementById('modal-overlay').style.display = 'block';
            document.getElementById('setting-modal').style.display = 'block';
            
            // 更新标题输入框，反映main-title的当前值
            const mainTitle = document.getElementById('main-title');
            const titleInput = document.getElementById('title-input');
            if (mainTitle && titleInput) {
                // 从localStorage加载保存的标题
                const savedTitle = localStorage.getItem('tiermaker-custom-title');
                if (savedTitle) {
                    mainTitle.textContent = savedTitle;
                    titleInput.value = savedTitle;
                } else {
                    titleInput.value = mainTitle.textContent.trim();
                }
                
                // 移除现有的事件监听器（如果有）
                titleInput.removeEventListener('input', titleInput._titleInputHandler);
                
                // 创建新的事件处理函数
                titleInput._titleInputHandler = function(e) {
                    const newTitle = e.target.value;
                    mainTitle.textContent = newTitle;
                    localStorage.setItem('tiermaker-custom-title', newTitle);
                    console.log('Title saved:', newTitle);
                };
                
                // 添加事件监听器
                titleInput.addEventListener('input', titleInput._titleInputHandler);
            }
            
            // 确保选择信息存在
            ensureSelectionInfoExists();
            
            // 渲染设置
            renderTierSettings();
            
            // 翻译设置面板
            i18n.translateSettingsModal();
            
            // 修复标题
            fixSettingsLabels();
            
            // 强制显示元素
            setTimeout(() => {
                forceDisplaySettingsElements();
                forceUpdateItemsCount();
            }, 100);
        });

        // 第二个设置按钮也使用相同处理
        document.getElementById('setting-btn2').addEventListener('click', () => {
            // 先显示模态窗口
            document.getElementById('modal-overlay').style.display = 'block';
            document.getElementById('setting-modal').style.display = 'block';
            
            // 更新标题输入框，反映main-title的当前值
            const mainTitle = document.getElementById('main-title');
            const titleInput = document.getElementById('title-input');
            if (mainTitle && titleInput) {
                // 从localStorage加载保存的标题
                const savedTitle = localStorage.getItem('tiermaker-custom-title');
                if (savedTitle) {
                    mainTitle.textContent = savedTitle;
                    titleInput.value = savedTitle;
                } else {
                    titleInput.value = mainTitle.textContent.trim();
                }
                
                // 移除现有的事件监听器（如果有）
                titleInput.removeEventListener('input', titleInput._titleInputHandler);
                
                // 创建新的事件处理函数
                titleInput._titleInputHandler = function(e) {
                    const newTitle = e.target.value;
                    mainTitle.textContent = newTitle;
                    localStorage.setItem('tiermaker-custom-title', newTitle);
                    console.log('Title saved:', newTitle);
                };
                
                // 添加事件监听器
                titleInput.addEventListener('input', titleInput._titleInputHandler);
            }
            
            // 从本地存储加载创建者名称
            const creatorNameInput = document.getElementById('creator-name-input');
            if (creatorNameInput) {
                const savedCreatorName = localStorage.getItem('tiermaker-creator-name') || '';
                creatorNameInput.value = savedCreatorName;
            }
            
            // tierManager.js已提供reorderTiers方法，不需要再添加
            // addTierManagerReorderMethod();
            
            // 确保选择信息存在
            ensureSelectionInfoExists();
            
            // 渲染设置
            renderTierSettings();
            
            // 翻译设置面板
            i18n.translateSettingsModal();
            
            // 修复标题
            fixSettingsLabels();
            
            // 强制显示元素
            setTimeout(() => {
                forceDisplaySettingsElements();
                forceUpdateItemsCount();
            }, 100);
        });

        // 在init函数中也确保选择信息存在
        let initDone = false;
        const originalInit = init;
        init = function() {
            // 避免重复初始化
            if (initDone) {
                return;
            }
            
            // 调用原始init
            originalInit();
            
            // 确保选择信息存在
            setTimeout(() => {
                ensureSelectionInfoExists();
                forceUpdateItemsCount();
                setupResetButton(); // 设置重置按钮
                setupDownloadButton(); // 设置下载按钮
                // Call after a slight delay to ensure DOM is ready and dimensions are available
                dynamicItemPreviewPositioning(); // Changed from 200ms timeout to direct call after other setups
                initDone = true;
            }, 500); // Keep overall delay for setups
        };

        // 在更新items计数的函数中也确保选择信息存在
        const originalUpdateItemsCount = updateItemsCount;
        updateItemsCount = function() {
            // 确保选择信息存在
            ensureSelectionInfoExists();
            
            // 调用原始函数
            originalUpdateItemsCount();
            
            // 如果设置对话框可见，立即更新其中的计数
            updateSettingsItemCount();
        };

        // 使用Canvas API生成文字图片
        function generateTextCardImage(text, width = 300, height = 450) {
            // 根据当前图像比例调整宽高
            let aspectRatio = getAspectRatioValues(currentImageRatio);
            if (aspectRatio) {
                // 保持总面积大致相同
                const area = width * height;
                const newHeight = Math.sqrt(area / aspectRatio);
                const newWidth = newHeight * aspectRatio;
                
                width = Math.round(newWidth);
                height = Math.round(newHeight);
                
                console.log(`为${currentImageRatio}比例调整图片尺寸: ${width}x${height}`);
            }
            
            // 创建Canvas元素
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            
            // 获取绘图上下文
            const ctx = canvas.getContext('2d');
            
            // 绘制背景
            ctx.fillStyle = '#ffffff';  // 白色背景
            ctx.fillRect(0, 0, width, height);
            
            // 设置文本样式
            ctx.fillStyle = '#000000';  // 黑色文字
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // 根据文本长度动态调整字体大小
            const maxTextLength = text.length;
            let fontSize = 60; // 增大默认字体大小（原来是40）
            
            // 根据文本长度调整字号
            if (maxTextLength > 5) fontSize = 52;   // 原来是36
            if (maxTextLength > 10) fontSize = 46;  // 原来是32
            if (maxTextLength > 15) fontSize = 40;  // 原来是28
            if (maxTextLength > 20) fontSize = 34;  // 原来是24
            if (maxTextLength > 25) fontSize = 30;  // 原来是20
            if (maxTextLength > 30) fontSize = 26;  // 原来是18
            if (maxTextLength > 40) fontSize = 22;  // 原来是16
            if (maxTextLength > 50) fontSize = 18;  // 原来是14
            
            ctx.font = `bold ${fontSize}px Arial, "Microsoft YaHei", "微软雅黑", "SimHei", "黑体", sans-serif`;
            
            // 准备文本
            const maxCharsPerLine = Math.floor(width / (fontSize * 1.0)); // 增大系数从0.6到1.0，减少每行字符数
            const lines = [];
            let currentLine = '';
            
            // 分行处理
            for (let i = 0; i < text.length; i++) {
                currentLine += text[i];
                
                // 当达到每行最大字符数或遇到换行符时创建新行
                if (currentLine.length >= maxCharsPerLine || text[i] === '\n' || i === text.length - 1) {
                    lines.push(currentLine);
                    currentLine = '';
                }
            }
            
            // 如果最后一行有内容但未添加，则添加
            if (currentLine.length > 0) {
                lines.push(currentLine);
            }
            
            // 绘制多行文本
            const lineHeight = fontSize * 1.2;
            const totalTextHeight = lines.length * lineHeight;
            const startY = (height - totalTextHeight) / 2 + lineHeight / 2;
            
            // 逐行绘制文本
            lines.forEach((line, index) => {
                ctx.fillText(line, width / 2, startY + index * lineHeight);
            });
            
            // 添加边框
            ctx.strokeStyle = '#dddddd';
            ctx.lineWidth = 2;
            ctx.strokeRect(2, 2, width - 4, height - 4);
            
            // 如果是圆形比例，裁剪成圆形
            if (currentImageRatio === 'round') {
                const tempCanvas = document.createElement('canvas');
                const size = Math.min(width, height);
                tempCanvas.width = size;
                tempCanvas.height = size;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 创建圆形裁剪区域
                tempCtx.beginPath();
                tempCtx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
                tempCtx.closePath();
                tempCtx.clip();
                
                // 绘制原始canvas内容
                tempCtx.drawImage(canvas, (width-size)/2, (height-size)/2, size, size, 0, 0, size, size);
                
                // 转换为data URL
                return tempCanvas.toDataURL('image/png');
            }
            
            // 转换为data URL
            return canvas.toDataURL('image/png');
        }
        
        // 根据图像比例名称获取宽高比
        function getAspectRatioValues(ratioName) {
            switch(ratioName) {
                case 'portrait':
                    return 2/3; // 宽/高
                case 'landscape':
                    return 3/2;
                case 'square':
                case 'round':
                    return 1/1;
                default:
                    return null;
            }
        }

        // 为文字卡片更新图片
        function updateTextCardImage(item) {
            if (!item || !item.isTextGenerated) return;
            
            // 使用Canvas API生成新图片
            const newImgUrl = generateTextCardImage(item.title);
            
            // 更新图片URL
            item.img = newImgUrl;
            
            // 更新本地items中的图片
            const localItem = localItems.find(i => i.id === item.id);
            if (localItem) {
                localItem.img = newImgUrl;
            }
            
            // 更新图片缓存
            imageCache[item.id] = newImgUrl;
            
            console.log(`文字卡片图片已更新: ID=${item.id}, 文本="${item.title}"`);
        }

        // 从文本创建item
        function createItemsFromText(text) {
            if (!text) return;
            
            // 按行分割输入
            const lines = text.trim().split('\n').filter(line => line.trim());
            console.log(`从文本创建items: ${lines.length}行`);
            
            if (lines.length === 0) return;
            
            // 为每行创建一个item
            const newItems = lines.map(line => {
                // 创建唯一ID
                const id = Date.now() + Math.floor(Math.random() * 10000);
                
                // 使用Canvas API生成图片
                const imgUrl = generateTextCardImage(line);
                
                // 创建item对象
                return {
                    id,
                    title: line,
                    img: imgUrl,
                    isTextGenerated: true // 标记为文本生成的卡片
                };
            });
            
            // 添加到items和unclassifiedItems数组
            newItems.forEach(item => {
                items.push(item);
                localItems.push(item);
                unclassifiedItems.push(item.id);
                
                // 更新图片缓存
                imageCache[item.id] = item.img;
            });
            
            // 保存到localStorage
            saveItemsToLocalStorage();
            
            // 更新items计数 - 确保即使在设置对话框中也更新
            updateItemsCount();
            forceUpdateItemsCount();
            
            // 重新渲染
            rerenderAll();
            
            // 显示成功消息
            showSuccessMessage(i18n.t('cardsCreated', { count: newItems.length }));
        }

        // 设置标题编辑事件
        function setupResetButton() {
            const resetBtn = document.getElementById('reset-btn');
            if (resetBtn) {
                resetBtn.onclick = showResetConfirmDialog;
                console.log('Reset按钮已设置');
            } else {
                console.warn('找不到Reset按钮');
            }
        }

        // 显示重置确认对话框
        function showResetConfirmDialog() {
            // 显示模态窗口和遮罩
            document.getElementById('modal-overlay').style.display = 'block';
            document.getElementById('reset-confirm-modal').style.display = 'block';
            
            // 绑定确认按钮事件
            const confirmBtn = document.getElementById('confirm-reset-btn');
            const cancelBtn = document.getElementById('cancel-reset-btn');
            
            // 移除旧的事件监听器（如有）
            confirmBtn.removeEventListener('click', handleResetConfirm);
            cancelBtn.removeEventListener('click', handleResetCancel);
            
            // 添加新的事件监听器
            confirmBtn.addEventListener('click', handleResetConfirm);
            cancelBtn.addEventListener('click', handleResetCancel);
            
            // 确保使用正确的翻译
            if (typeof i18n !== 'undefined' && i18n.applyTranslations) {
                document.getElementById('confirm-reset-btn').textContent = i18n.t('confirmReset');
            }
        }

        // 处理重置确认
        function handleResetConfirm() {
            // 关闭模态窗口
            document.getElementById('modal-overlay').style.display = 'none';
            document.getElementById('reset-confirm-modal').style.display = 'none';
            
            // 执行重置操作
            performReset();
        }

        // 处理取消重置
        function handleResetCancel() {
            // 关闭模态窗口
            document.getElementById('modal-overlay').style.display = 'none';
            document.getElementById('reset-confirm-modal').style.display = 'none';
        }

        // 实际执行重置的函数
        function performReset() {
            console.log('重置所有项目分类和跳过状态');
            
            // 保存原始导入顺序的副本
            const originalOrder = [...items.map(item => item.id)];
            console.log('原始导入顺序:', originalOrder);
            
            // 将所有已分类项目移回未分类
            let allItemsToUnclassify = [];
            
            // 获取所有已分类项目ID
            classifiedItems.forEach(item => {
                if (!unclassifiedItems.includes(item.id)) {
                    allItemsToUnclassify.push(item.id);
                }
            });
            console.log('需要取消分类的项目:', allItemsToUnclassify);
            
            // 清空classifiedItems
            classifiedItems = [];
            
            // 将所有项目添加到未分类列表
            unclassifiedItems = unclassifiedItems.concat(allItemsToUnclassify);
            
            // 根据原始顺序重新排序未分类项目
            unclassifiedItems.sort((a, b) => {
                return originalOrder.indexOf(a) - originalOrder.indexOf(b);
            });
            
            // 清空跳过状态
            skippedItems.clear();
            saveSkippedItems();
            console.log('清空并保存跳过状态');
            
            // 重置预览状态
            previewIdx = 0;
            previewMode = 'unclassified';
            
            // 保存分类状态 - 替换为更全面的保存函数
            saveItemsToLocalStorage();
            console.log('保存所有数据到本地存储');
            
            // 重新渲染
            rerenderAll();
            console.log('重置完成，未分类项目:', unclassifiedItems);
            
            // 显示成功消息
            showSuccessMessage(i18n.t('resetSuccess') || '重置成功');
        }

        // 修改原有的resetAllItems函数为showResetConfirmDialog
        function resetAllItems() {
            showResetConfirmDialog();
        }

        // 单独更新tier设置面板中的颜色，不重新创建Sortable
        function updateTierSettingsColors() {
            // 遍历设置面板中的所有tier行
            const rows = document.querySelectorAll('#tier-settings-body tr');
            rows.forEach(row => {
                const tier = row.getAttribute('data-tier');
                if (!tier) return;
                
                // 找到颜色预览元素
                const colorPreview = row.querySelector('.tier-color-preview');
                if (colorPreview) {
                    // 更新颜色
                    const tierColor = tierManager.getTierColor(tier);
                    colorPreview.style.backgroundColor = tierColor;
                }
            });
        }

        // 设置下载按钮事件
        function setupDownloadButton() {
            const downloadBtn = document.getElementById('download-btn');
            if (downloadBtn) {
                downloadBtn.onclick = downloadAllItems;
                console.log('Download按钮已设置');
            } else {
                console.warn('找不到Download按钮');
            }
        }

        // 获取图片的二进制数据
        async function getImageBinary(url) {
            try {
                // 如果是Data URL，直接转换为Blob
                if (url.startsWith('data:')) {
                    const response = await fetch(url);
                    return await response.blob();
                }
                
                // 如果是外部URL，通过fetch获取
                const response = await fetch(url, { mode: 'cors' });
                return await response.blob();
            } catch (error) {
                console.error('获取图片二进制数据失败:', error);
                // 返回一个空的Blob作为错误的替代
                return new Blob(['Error loading image'], {type: 'text/plain'});
            }
        }

        // 提取文件扩展名
        function getExtensionFromUrl(url) {
            if (url.startsWith('data:image/')) {
                // 从data URL提取MIME类型
                const match = url.match(/data:image\/([a-zA-Z0-9]+);/);
                return match ? match[1] : 'png';
            } else {
                // 从URL提取扩展名
                const match = url.match(/\.([a-zA-Z0-9]+)(?:\?|$)/);
                return match ? match[1] : 'jpg';
            }
        }

        // 下载所有未跳过的项目图片
        async function downloadAllItems() {
            console.log("downloadAllItems函数被调用");
            try {
                // 显示加载指示器
                showLoadingIndicator();
                
                // 确保items变量存在且为数组
                if (!items || !Array.isArray(items)) {
                    console.error("items变量不存在或不是数组:", items);
                    alert("无法访问项目数据，请刷新页面后重试");
                    hideLoadingIndicator();
                    return;
                }
                
                // 确保skippedItems变量存在
                if (!skippedItems) {
                    console.error("skippedItems变量不存在");
                    skippedItems = new Set(); // 创建一个空Set作为后备
                }
                
                // 收集所有未跳过的项目
                const itemsToDownload = items.filter(item => !skippedItems.has(item.id));
                console.log(`准备下载 ${itemsToDownload.length} 个项目的图片:`, itemsToDownload);
                
                if (itemsToDownload.length === 0) {
                    console.log("没有项目可下载");
                    
                    // 确保i18n可用
                    let message = "没有项目可下载，所有项目都已被跳过。";
                    try {
                        message = i18n.t('noItemsToDownload');
                    } catch (e) {
                        console.error("i18n调用失败:", e);
                    }
                    
                    alert(message);
                    hideLoadingIndicator();
                    return;
                }
                
                // 检查JSZip是否可用
                if (typeof JSZip !== 'function') {
                    console.error("找不到JSZip库，请确保已加载JSZip");
                    alert("找不到压缩功能，请确保网络连接正常并刷新页面");
                    hideLoadingIndicator();
                    return;
                }
                
                // 创建一个新的JSZip实例
                const zip = new JSZip();
                
                // 创建进度计数器
                let processedCount = 0;
                
                // 最大并发请求数
                const MAX_CONCURRENT = 5;
                
                // 分批处理图片
                for (let i = 0; i < itemsToDownload.length; i += MAX_CONCURRENT) {
                    const batch = itemsToDownload.slice(i, i + MAX_CONCURRENT);
                    console.log(`处理批次 ${i/MAX_CONCURRENT + 1}/${Math.ceil(itemsToDownload.length/MAX_CONCURRENT)}`);
                    
                    // 并发处理当前批次
                    await Promise.all(batch.map(async (item, index) => {
                        try {
                            // 获取图片扩展名
                            const extension = getExtensionFromUrl(item.img);
                            
                            // 构建安全的文件名 - 直接使用item的标题，不添加item_和ID前缀
                            const title = item.title || "无标题";
                            const fileName = `${title.replace(/[^a-zA-Z0-9_\u4e00-\u9fa5]/g, '_').substring(0, 100)}.${extension}`;
                            console.log(`处理项目: ${item.id}, 文件名: ${fileName}`);
                            
                            // 获取图片的二进制数据
                            const imageBlob = await getImageBinary(item.img);
                            
                            // 检查blob是否有效
                            if (!imageBlob || imageBlob.size === 0) {
                                console.error(`项目 ${item.id} 的图片无效`);
                                return;
                            }
                            
                            // 将图片添加到zip
                            zip.file(fileName, imageBlob);
                            console.log(`项目 ${item.id} 已添加到zip`);
                            
                            // 更新进度
                            processedCount++;
                            updateLoadingProgress(processedCount, itemsToDownload.length);
                            
                        } catch (err) {
                            console.error(`处理项目 ${item.id} 失败:`, err);
                        }
                    }));
                }
                
                // 生成zip文件
                console.log("正在生成zip文件...");
                let generatingZipText = "生成压缩文件中";
                try {
                    generatingZipText = i18n.t('generatingZip');
                } catch (e) {
                    console.warn("i18n查找翻译失败，使用默认文本");
                }
                
                const content = await zip.generateAsync({
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: {
                        level: 6
                    }
                }, (metadata) => {
                    updateLoadingProgress(metadata.percent | 0, 100, generatingZipText);
                });
                
                console.log("zip文件生成完成，大小:", content.size);
                
                // 创建下载链接
                const url = URL.createObjectURL(content);
                const link = document.createElement("a");
                link.href = url;
                
                // 设置文件名
                const mainTitle = document.getElementById('main-title');
                const title = mainTitle ? mainTitle.textContent : "TierMaker";
                const safeTitle = title.replace(/[^a-zA-Z0-9_\u4e00-\u9fa5]/g, '_').substring(0, 50);
                link.download = `tiermaker_${safeTitle}_${new Date().toISOString().slice(0,10)}.zip`;
                
                console.log("准备下载文件:", link.download);
                
                // 触发下载
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // 清理URL对象
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 100);
                
                console.log("下载完成!");
                
                // 显示成功消息
                let completeMessage = "下载完成";
                try {
                    completeMessage = i18n.t('downloadComplete');
                } catch (e) {
                    console.warn("i18n查找翻译失败，使用默认文本");
                }
                showSuccessMessage(completeMessage);
                
            } catch (error) {
                console.error("下载失败:", error);
                
                let errorMessage = "下载失败";
                try {
                    errorMessage = i18n.t('downloadError');
                } catch (e) {
                    console.warn("i18n查找翻译失败，使用默认文本");
                }
                
                alert(errorMessage + ": " + (error.message || "未知错误"));
            } finally {
                // 隐藏加载指示器
                hideLoadingIndicator();
            }
        }

        // 显示加载指示器
        function showLoadingIndicator() {
            console.log("显示加载指示器");
            let loadingOverlay = document.getElementById('loading-overlay');
            
            if (!loadingOverlay) {
                loadingOverlay = document.createElement('div');
                loadingOverlay.id = 'loading-overlay';
                loadingOverlay.style.position = 'fixed';
                loadingOverlay.style.top = '0';
                loadingOverlay.style.left = '0';
                loadingOverlay.style.width = '100%';
                loadingOverlay.style.height = '100%';
                loadingOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                loadingOverlay.style.display = 'flex';
                loadingOverlay.style.flexDirection = 'column';
                loadingOverlay.style.justifyContent = 'center';
                loadingOverlay.style.alignItems = 'center';
                loadingOverlay.style.zIndex = '9999';
                
                const spinner = document.createElement('div');
                spinner.className = 'loading-spinner';
                spinner.style.border = '5px solid #f3f3f3';
                spinner.style.borderTop = '5px solid #3498db';
                spinner.style.borderRadius = '50%';
                spinner.style.width = '50px';
                spinner.style.height = '50px';
                spinner.style.animation = 'spin 2s linear infinite';
                
                const loadingText = document.createElement('div');
                loadingText.id = 'loading-text';
                loadingText.style.color = 'white';
                loadingText.style.marginTop = '20px';
                loadingText.style.fontSize = '18px';
                
                // 获取翻译文本，添加错误处理
                let preparingText = "准备下载...";
                try {
                    preparingText = i18n.t('preparingDownload');
                } catch (e) {
                    console.warn("i18n翻译调用失败，使用默认文本:", e);
                }
                loadingText.textContent = preparingText;
                
                const progressBar = document.createElement('div');
                progressBar.style.width = '300px';
                progressBar.style.height = '20px';
                progressBar.style.backgroundColor = '#444';
                progressBar.style.marginTop = '15px';
                progressBar.style.borderRadius = '10px';
                progressBar.style.overflow = 'hidden';
                
                const progressFill = document.createElement('div');
                progressFill.id = 'progress-fill';
                progressFill.style.width = '0%';
                progressFill.style.height = '100%';
                progressFill.style.backgroundColor = '#3498db';
                progressFill.style.transition = 'width 0.3s';
                
                progressBar.appendChild(progressFill);
                loadingOverlay.appendChild(spinner);
                loadingOverlay.appendChild(loadingText);
                loadingOverlay.appendChild(progressBar);
                
                // 添加CSS动画
                const style = document.createElement('style');
                style.innerHTML = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(loadingOverlay);
                console.log("加载指示器已创建");
            } else {
                // 获取翻译文本，添加错误处理
                let preparingText = "准备下载...";
                try {
                    preparingText = i18n.t('preparingDownload');
                } catch (e) {
                    console.warn("i18n翻译调用失败，使用默认文本:", e);
                }
                
                const loadingText = document.getElementById('loading-text');
                if (loadingText) {
                    loadingText.textContent = preparingText;
                }
                
                const progressFill = document.getElementById('progress-fill');
                if (progressFill) {
                    progressFill.style.width = '0%';
                }
                
                loadingOverlay.style.display = 'flex';
                console.log("加载指示器已显示");
            }
        }

        // 隐藏加载指示器
        function hideLoadingIndicator() {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
        }

        // 更新加载进度
        function updateLoadingProgress(current, total, customMessage = null) {
            console.log(`更新进度: ${current}/${total} (${Math.floor((current/total)*100)}%)`);
            const percentage = Math.min(100, Math.floor((current / total) * 100));
            const progressFill = document.getElementById('progress-fill');
            const loadingText = document.getElementById('loading-text');
            
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
            } else {
                console.warn('找不到进度条元素 progress-fill');
            }
            
            if (loadingText) {
                try {
                    if (customMessage) {
                        loadingText.textContent = `${customMessage} (${percentage}%)`;
                    } else {
                        let processingText = "处理图片中";
                        try {
                            processingText = i18n.t('processingImages');
                        } catch (e) {
                            console.warn('i18n翻译调用失败，使用默认文本');
                        }
                        loadingText.textContent = `${processingText}: ${current}/${total} (${percentage}%)`;
                    }
                } catch (e) {
                    console.error('更新加载文本时出错:', e);
                }
            } else {
                console.warn('找不到加载文本元素 loading-text');
            }
        }
        
        // 添加直接事件绑定，确保下载按钮事件被正确设置
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded - 准备绑定下载按钮');
            const downloadBtn = document.getElementById('download-btn');
            if (downloadBtn) {
                console.log('找到下载按钮，正在绑定事件');
                downloadBtn.addEventListener('click', function() {
                    console.log('下载按钮被点击');
                    downloadAllItems();
                });
            } else {
                console.error('找不到下载按钮元素!');
            }
        });

        // 添加在document.addEventListener('DOMContentLoaded', function() { 后面

        // 设置item-preview浮动居中
        // function setupItemPreviewFloat() { // This function is now replaced/enhanced by dynamicItemPreviewPositioning
        //     // 只在非手机屏幕上应用
        //     if (window.innerWidth < 768) return;
            
        //     const mainContainer = document.querySelector('.main-container');
        //     const itemPreview = document.querySelector('.item-preview');
            
        //     if (!mainContainer || !itemPreview) return;
            
        //     // 确保主容器有正确的样式
        //     mainContainer.style.display = 'flex';
        //     mainContainer.style.alignItems = 'flex-start';
        //     mainContainer.style.position = 'relative';
            
        //     // 设置tierListContainer
        //     const tierListContainer = document.querySelector('.tier-list-container');
        //     if (tierListContainer) {
        //         tierListContainer.style.flex = '1';
        //         tierListContainer.style.marginRight = '10px';
        //     }
            
        //     // 设置itemPreview
        //     itemPreview.style.position = 'sticky';
        //     itemPreview.style.top = '50vh';
        //     itemPreview.style.transform = 'translateY(-50%)';
        //     itemPreview.style.maxHeight = '90vh';
        //     itemPreview.style.width = '300px';
        //     itemPreview.style.flexShrink = '0';
        //     itemPreview.style.zIndex = '5';
            
        //     console.log('Item Preview 浮动设置已应用');
        // }
        
        // 页面加载和窗口调整大小时都应用设置
        // window.addEventListener('load', setupItemPreviewFloat); // Replaced by dynamicItemPreviewPositioning listeners
        // window.addEventListener('resize', setupItemPreviewFloat); // Replaced by dynamicItemPreviewPositioning listeners


        // ========== New JavaScript for dynamic item preview positioning ==========
        function dynamicItemPreviewPositioning() {
            const itemPreview = document.querySelector('.item-preview');
            const tierListContainer = document.querySelector('.tier-list-container'); // Needed for horizontal positioning
            const itemsContainer = document.querySelector('.items-container');
            const header = document.querySelector('.header');

            if (!itemPreview || !tierListContainer || !itemsContainer || !header) {
                console.warn('DynamicPositioning: Missing one or more required elements.');
                return;
            }

            if (window.innerWidth < 768) {
                // For smaller screens, reset styles if it was fixed, or rely on base CSS
                itemPreview.style.position = ''; // Revert to default (likely from base.css or layout.css)
                itemPreview.style.top = '';
                itemPreview.style.left = '';
                itemPreview.style.transform = '';
                return;
            } else {
                // Ensure it's fixed for larger screens if previously reset
                itemPreview.style.position = 'fixed';
                itemPreview.style.transform = 'translateY(-50%)'; // Re-apply transform if cleared
            }
            
            const viewportHeight = window.innerHeight;
            const itemPreviewHeight = itemPreview.offsetHeight;
            const headerRect = header.getBoundingClientRect();
            const itemsContainerRect = itemsContainer.getBoundingClientRect();
            const tierListContainerRect = tierListContainer.getBoundingClientRect();

            if (itemPreviewHeight === 0) {
                console.warn('DynamicPositioning: itemPreviewHeight is 0, skipping.');
                return; 
            }

            // Vertical Positioning
            const gap = 10; // Universal gap
            const idealCenterY = viewportHeight / 2;

            // Define bounds for the center of itemPreview
            const lowerBoundFromHeader = headerRect.bottom + (itemPreviewHeight / 2) + gap;
            const upperBoundFromItemsContainer = itemsContainerRect.top - (itemPreviewHeight / 2) - gap;

            let effectiveLowerBound = lowerBoundFromHeader;
            const absMinTop = 20;
            if (headerRect.bottom < absMinTop) {
                // If header is scrolled out, there's an additional effective lower bound 
                // to keep the top of itemPreview at least at absMinTop.
                const lowerBoundFromAbsMinTop = absMinTop + (itemPreviewHeight / 2);
                effectiveLowerBound = Math.max(lowerBoundFromHeader, lowerBoundFromAbsMinTop);
            }

            let targetCenterY = idealCenterY;
            targetCenterY = Math.max(targetCenterY, effectiveLowerBound); // Apply the most restrictive lower bound
            targetCenterY = Math.min(targetCenterY, upperBoundFromItemsContainer); // Always respect the upper bound from items container
            
            itemPreview.style.top = targetCenterY + 'px';

            // Horizontal Positioning
            itemPreview.style.left = tierListContainerRect.right + gap + 'px';

            const calculatedTopEdge = targetCenterY - (itemPreviewHeight / 2);
            const calculatedBottomEdge = targetCenterY + (itemPreviewHeight / 2);

            console.log('[Debug] Final Positioning:', {
                targetCenterY_final: targetCenterY,
                styleTopApplied: itemPreview.style.top,
                calculatedTopEdge_viewport: calculatedTopEdge,
                calculatedBottomEdge_viewport: calculatedBottomEdge,
                itemsContainer_actualTop_viewport: itemsContainerRect.top,
                header_actualBottom_viewport: headerRect.bottom,
                itemPreviewHeight_used: itemPreviewHeight,
                viewportHeight_used: viewportHeight,
                minCenterY_calc: effectiveLowerBound, // Updated to show the actual lower bound used
                maxCenterY_calc: upperBoundFromItemsContainer,
                idealCenterY_calc: idealCenterY
            });
        }

        window.addEventListener('scroll', dynamicItemPreviewPositioning, { passive: true });
        window.addEventListener('resize', dynamicItemPreviewPositioning);

        window.addEventListener('load', () => {
            setTimeout(dynamicItemPreviewPositioning, 200); 
        });

        const existingRerenderAll = rerenderAll; 
        rerenderAll = function() {
            existingRerenderAll();
            setTimeout(dynamicItemPreviewPositioning, 0);
        }
        // ========== End of new JavaScript ==========


        // ========== 分享功能实现 ==========

        // 设置分享按钮点击事件
        document.getElementById('share-btn').addEventListener('click', () => {
            openShareModal();
        });

        // 打开分享模态窗口后直接绑定关闭按钮事件
        document.querySelectorAll('.close-share-modal').forEach(btn => {
            btn.onclick = closeShareModal;
        });

        // 打开分享模态窗口
        function openShareModal() {
            // 显示模态窗口和遮罩
            document.getElementById('modal-overlay').style.display = 'block';
            document.getElementById('share-modal').style.display = 'block';
            
            // 生成预览
            generateTierListPreview();
            
            // 更新分享链接
            updateShareLink();
            
            // 翻译界面
            translateShareModal();
            
            // 绑定事件
            setupShareEvents();
        }

        // 生成预览图
        function generateTierListPreview() {
            const previewContainer = document.getElementById('tierlist-preview');
            previewContainer.innerHTML = '<p data-i18n="previewGenerating">Generating preview...</p>';
            
            // 防止在未渲染完成前进行操作
            setTimeout(() => {
                try {
                    // 克隆tier-list-container的内容
                    const tierList = document.querySelector('.tier-list-container');
                    if (!tierList) {
                        previewContainer.innerHTML = '<p>Error: Tier list not found.</p>';
                        return;
                    }
                    
                    // 创建一个包含标题和tier list的新容器
                    const previewContent = document.createElement('div');
                    previewContent.className = 'preview-content';
                    previewContent.style.width = '100%';
                    
                    // 添加标题
                    const titleClone = document.createElement('h2');
                    titleClone.textContent = document.getElementById('main-title').textContent;
                    titleClone.style.textAlign = 'center';
                    titleClone.style.margin = '0 0 15px 0';
                    titleClone.style.padding = '5px';
                    titleClone.style.color = 'white';
                    previewContent.appendChild(titleClone);
                    
                    // 克隆tier list（深度克隆以包含子元素）
                    const tierListClone = tierList.cloneNode(true);
                    tierListClone.style.width = '100%';
                    tierListClone.style.maxWidth = '700px';
                    tierListClone.style.margin = '0 auto';
                    
                    // 添加水印
                    const watermarkTop = document.createElement('div');
                    watermarkTop.className = 'watermark watermark-top';
                    watermarkTop.textContent = 'Made by TierMaster';

                    // 检查是否有创建者名称
                    const creatorName = localStorage.getItem('tiermaker-creator-name');
                    if (creatorName && creatorName.trim() !== '') {
                        const creatorLabelTop = document.createElement('div');
                        creatorLabelTop.className = 'watermark watermark-top';
                        creatorLabelTop.style.top = '30px';
                        creatorLabelTop.textContent = i18n.t('createdBy', {name: '@' + creatorName.trim()});
                        previewContent.appendChild(creatorLabelTop);
                    }
                    
                    // 添加右下角水印
                    const watermarkBottom = document.createElement('div');
                    watermarkBottom.className = 'watermark watermark-bottom';
                    watermarkBottom.textContent = 'Made by TierMaster';

                    // 添加创建者信息到右下角
                    if (creatorName && creatorName.trim() !== '') {
                        const creatorLabelBottom = document.createElement('div');
                        creatorLabelBottom.className = 'watermark watermark-bottom';
                        creatorLabelBottom.style.bottom = '30px';
                        creatorLabelBottom.textContent = i18n.t('createdBy', {name: '@' + creatorName.trim()});
                        previewContent.appendChild(creatorLabelBottom);
                    }
                    
                    // 添加到预览内容 - 注意顺序：先添加tier list
                    previewContent.appendChild(tierListClone);
                    previewContent.appendChild(watermarkTop);
                    previewContent.appendChild(watermarkBottom);
                    
                    // 添加评论部分 - 在tier list之后
                    const commentsWithItems = Object.entries(itemComments).filter(([id, comment]) => comment.trim());
                    const commentElements = [];

                    if (commentsWithItems.length > 0) {
                        commentsWithItems.forEach(([id, comment]) => {
                            const item = items.find(i => String(i.id) === String(id));
                            if (!item) return; // Skip if item not found for this comment

                            const commentItem = document.createElement('div');
                            commentItem.className = 'preview-comment-item';
                            
                            // 添加缩略图
                            const thumbnail = document.createElement('div');
                            thumbnail.className = 'preview-comment-thumbnail';
                            const thumbnailImg = document.createElement('img');
                            thumbnailImg.src = item.img;
                            thumbnailImg.alt = item.title || 'Untitled';
                            thumbnail.appendChild(thumbnailImg);
                            
                            // 添加评论内容容器
                            const content = document.createElement('div');
                            content.className = 'preview-comment-content';
                            
                            const title = document.createElement('div');
                            title.className = 'preview-comment-title';
                            title.textContent = item.title || 'Untitled';
                            
                            const text = document.createElement('div');
                            text.className = 'preview-comment-text';
                            text.textContent = comment;

                            content.appendChild(title);
                            content.appendChild(text);
                            
                            commentItem.appendChild(thumbnail);
                            commentItem.appendChild(content);
                            commentElements.push(commentItem);
                        });
                    }

                    if (commentElements.length > 0) { // Only add section if there are actual elements
                        const commentsSection = document.createElement('div');
                        commentsSection.className = 'preview-comments';
                        
                        const commentsTitle = document.createElement('h3');
                        commentsTitle.textContent = i18n.t('comments') || 'Comments';
                        commentsTitle.style.color = '#fff';
                        commentsTitle.style.marginBottom = '15px';
                        commentsSection.appendChild(commentsTitle);

                        commentElements.forEach(el => commentsSection.appendChild(el));
                        
                        previewContent.appendChild(commentsSection);
                    }
                    
                    // 清空并添加到预览容器
                    previewContainer.innerHTML = '';
                    previewContainer.appendChild(previewContent);
                    
                    // 调整预览高度
                    previewContainer.style.height = 'auto';
                    previewContainer.style.maxHeight = '400px';
                    
                    // 确保预览容器滚动到顶部
                    previewContainer.scrollTop = 0;
                    
                    console.log('Tier list preview generated with comments');
                } catch (e) {
                    console.error('Error generating preview:', e);
                    previewContainer.innerHTML = '<p>Error generating preview.</p>';
                }
            }, 100);
        }

        // 更新分享链接
        function updateShareLink() {
            const linkInput = document.getElementById('share-link-input');
            if (linkInput) {
                // 使用当前URL，未来可以改为生成唯一分享链接
                linkInput.value = window.location.href;
            }
        }

        // 翻译分享模态窗口
        function translateShareModal() {
            if (typeof i18n !== 'undefined' && i18n.applyTranslations) {
                try {
                    i18n.applyTranslations(document.getElementById('share-modal'));
                } catch (e) {
                    console.error('Error translating share modal:', e);
                }
            }
        }

        // 设置分享相关事件
        function setupShareEvents() {
            // 下载图片按钮
            const downloadBtn = document.getElementById('download-image-btn');
            if (downloadBtn) {
                downloadBtn.onclick = downloadTierListAsImage;
            }
            
            // 复制链接按钮
            const copyBtn = document.getElementById('copy-link-btn');
            if (copyBtn) {
                copyBtn.onclick = copyShareLink;
            }
            
            // 社交媒体分享按钮
            document.querySelectorAll('.social-btn').forEach(btn => {
                btn.onclick = () => shareToSocialMedia(btn.getAttribute('data-platform'));
            });
            
            // 关闭按钮
            document.querySelector('.close-share-modal').onclick = closeShareModal;
        }

        // 关闭分享模态窗口
        function closeShareModal() {
            document.getElementById('modal-overlay').style.display = 'none';
            document.getElementById('share-modal').style.display = 'none';
        }

        // 将Tier List下载为图片
        async function downloadTierListAsImage() {
            try {
                showLoadingIndicator('正在生成图片...');
                
                // 获取预览内容
                const previewContent = document.querySelector('.preview-content');
                if (!previewContent) {
                    console.error('Preview content not found');
                    hideLoadingIndicator();
                    return;
                }
                
                // 使用html2canvas库转换为Canvas
                // 如果html2canvas库未加载，添加库
                if (typeof html2canvas !== 'function') {
                    await loadHtml2Canvas();
                }
                
                // 使用html2canvas捕获内容
                const canvas = await html2canvas(previewContent, {
                    backgroundColor: '#1a1a1a',
                    scale: 2, // 提高清晰度
                    logging: false,
                    useCORS: true // 允许加载跨域图片
                });
                
                // 转换为图片
                const imgData = canvas.toDataURL('image/png');
                
                // 创建下载链接
                const link = document.createElement('a');
                link.href = imgData;
                link.download = `TierList_${document.getElementById('main-title').textContent.replace(/[^a-zA-Z0-9_\u4e00-\u9fa5]/g, '_')}_${new Date().toISOString().slice(0,10)}.png`;
                
                // 触发下载
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                hideLoadingIndicator();
                
                // 显示成功消息
                showSuccessMessage(i18n.t('downloadSuccess') || 'Image downloaded successfully');
            } catch (error) {
                console.error('Error downloading image:', error);
                hideLoadingIndicator();
                alert('Error generating image. Please try again.');
            }
        }

        // 加载html2canvas库
        function loadHtml2Canvas() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://html2canvas.hertzen.com/dist/html2canvas.min.js';
                script.onload = resolve;
                script.onerror = () => reject(new Error('Failed to load html2canvas'));
                document.head.appendChild(script);
            });
        }

        // 复制分享链接
        function copyShareLink() {
            const linkInput = document.getElementById('share-link-input');
            if (!linkInput) return;
            
            // 选择并复制
            linkInput.select();
            linkInput.setSelectionRange(0, 99999);
            
            try {
                // 使用新API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(linkInput.value)
                        .then(() => {
                            // 显示成功消息
                            const copyBtn = document.getElementById('copy-link-btn');
                            const originalText = copyBtn.textContent;
                            copyBtn.textContent = i18n.t('copied') || 'Copied!';
                            
                            // 恢复原文本
                            setTimeout(() => {
                                copyBtn.textContent = originalText;
                            }, 2000);
                        })
                        .catch(err => {
                            console.error('Failed to copy: ', err);
                            // 回退到传统方法
                            document.execCommand('copy');
                        });
                } else {
                    // 传统方法
                    document.execCommand('copy');
                    
                    // 显示成功消息
                    const copyBtn = document.getElementById('copy-link-btn');
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = i18n.t('copied') || 'Copied!';
                    
                    // 恢复原文本
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                    }, 2000);
                }
            } catch (err) {
                console.error('Failed to copy: ', err);
                alert('Failed to copy link');
            }
        }

        // 分享到社交媒体
        async function shareToSocialMedia(platform) {
            try {
                // 首先生成图片
                showLoadingIndicator(i18n.t('preparingShare') || 'Preparing to share...');
                
                // 获取预览内容
                const previewContent = document.querySelector('.preview-content');
                if (!previewContent) {
                    hideLoadingIndicator();
                    alert('Error: Preview content not found');
                    return;
                }
                
                // 加载html2canvas库（如果需要）
                if (typeof html2canvas !== 'function') {
                    await loadHtml2Canvas();
                }
                
                // 捕获内容为图片
                const canvas = await html2canvas(previewContent, {
                    backgroundColor: '#1a1a1a',
                    scale: 2,
                    logging: false,
                    useCORS: true
                });
                
                // 获取图片数据
                const imgData = canvas.toDataURL('image/png');
                
                hideLoadingIndicator();
                
                // 获取分享文本
                const shareTitle = document.getElementById('main-title').textContent;
                const shareText = `Check out my tier list: ${shareTitle}`;
                const shareUrl = window.location.href;
                
                // 根据平台进行分享
                switch (platform) {
                    case 'twitter':
                        // Twitter/X 分享
                        window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(shareUrl)}`, '_blank');
                        break;
                        
                    case 'facebook':
                        // Facebook 分享
                        window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}`, '_blank');
                        break;
                        
                    case 'reddit':
                        // Reddit 分享
                        window.open(`https://www.reddit.com/submit?url=${encodeURIComponent(shareUrl)}&title=${encodeURIComponent(shareTitle)}`, '_blank');
                        break;
                        
                    case 'weibo':
                        // 微博分享
                        window.open(`http://service.weibo.com/share/share.php?url=${encodeURIComponent(shareUrl)}&title=${encodeURIComponent(shareText)}`, '_blank');
                        break;
                        
                    case 'wechat':
                        // 微信分享需要显示二维码
                        showWeChatQRCode(shareUrl);
                        break;
                        
                    default:
                        alert('Sharing to ' + platform + ' is not supported yet.');
                }
            } catch (error) {
                console.error('Error sharing to social media:', error);
                hideLoadingIndicator();
                alert('Error sharing. Please try again.');
            }
        }

        // 显示微信分享二维码
        function showWeChatQRCode(url) {
            // 创建一个模态窗口显示二维码
            const qrModal = document.createElement('div');
            qrModal.className = 'qr-modal';
            qrModal.style.position = 'fixed';
            qrModal.style.top = '50%';
            qrModal.style.left = '50%';
            qrModal.style.transform = 'translate(-50%, -50%)';
            qrModal.style.backgroundColor = 'white';
            qrModal.style.padding = '20px';
            qrModal.style.borderRadius = '10px';
            qrModal.style.zIndex = '10000';
            qrModal.style.textAlign = 'center';
            
            // 添加标题
            const title = document.createElement('h3');
            title.textContent = i18n.t('wechatScan') || 'Scan with WeChat';
            title.style.marginBottom = '15px';
            title.style.color = 'black';
            qrModal.appendChild(title);
            
            // 生成二维码的容器
            const qrContainer = document.createElement('div');
            qrContainer.id = 'qrcode-container';
            qrContainer.style.width = '200px';
            qrContainer.style.height = '200px';
            qrContainer.style.margin = '0 auto';
            qrContainer.style.backgroundColor = '#f0f0f0';
            qrModal.appendChild(qrContainer);
            
            // 添加说明文字
            const desc = document.createElement('p');
            desc.textContent = i18n.t('wechatShareTip') || 'Open WeChat and scan this QR code to share';
            desc.style.marginTop = '15px';
            desc.style.fontSize = '14px';
            desc.style.color = '#666';
            qrModal.appendChild(desc);
            
            // 添加关闭按钮
            const closeBtn = document.createElement('button');
            closeBtn.textContent = i18n.t('close') || 'Close';
            closeBtn.style.marginTop = '15px';
            closeBtn.style.padding = '8px 15px';
            closeBtn.style.border = 'none';
            closeBtn.style.borderRadius = '5px';
            closeBtn.style.backgroundColor = '#333';
            closeBtn.style.color = 'white';
            closeBtn.style.cursor = 'pointer';
            closeBtn.onclick = () => {
                document.body.removeChild(qrModal);
                document.body.removeChild(overlay);
            };
            qrModal.appendChild(closeBtn);
            
            // 创建半透明遮罩
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            overlay.style.zIndex = '9999';
            overlay.onclick = () => {
                document.body.removeChild(qrModal);
                document.body.removeChild(overlay);
            };
            
            // 添加到body
            document.body.appendChild(overlay);
            document.body.appendChild(qrModal);
            
            // 加载QRCode库，然后生成二维码
            if (typeof QRCode !== 'function') {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js';
                script.onload = () => {
                    new QRCode(document.getElementById('qrcode-container'), {
                        text: url,
                        width: 200,
                        height: 200,
                        colorDark: '#000000',
                        colorLight: '#ffffff',
                        correctLevel: QRCode.CorrectLevel.H
                    });
                };
                script.onerror = () => {
                    document.getElementById('qrcode-container').textContent = 'Failed to load QR code generator.';
                };
                document.head.appendChild(script);
            } else {
                new QRCode(document.getElementById('qrcode-container'), {
                    text: url,
                    width: 200,
                    height: 200,
                    colorDark: '#000000',
                    colorLight: '#ffffff',
                    correctLevel: QRCode.CorrectLevel.H
                });
            }
        }
    </script>
</body>
</html>